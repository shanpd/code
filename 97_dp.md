### 算法

![1651554973256](dp_img\1651554973256.png)

### 一、分而冶之



###                                                二、动态规划

##### 01、 数塔取数问题

一个高度为N的由正整数组成的三角形，从上走到下，求经过的数字和的最大值。 
每次只能走到下一层相邻的数上，例如从第3层的6向下走，只能走到第4层的2或9上。

该三角形第n层有n个数字，例如：

第一层有一个数字：5

第二层有两个数字：8 4

第三层有三个数字：3 6 9

第四层有四个数字：7 2 9 5

最优方案是：5 + 8 + 6 + 9 = 28

注意:上面应该是排列成一个三角形的样子不是竖向对应的，排版问题没有显示成三角形。

状态定义: Fi，j是第i行j列项最大取数和，求第n行Fn，m（0 < m < n）中最大值。

状态转移方程：Fi，j = max{Fi-1,j-1,Fi-1,j}+Ai,jt

```java
import java.util.Scanner;

public class Dp01 {

    /**
     * 数塔取数问题
     */
    public static void main(String[] args) {

        Scanner sc = new Scanner(System.in);

        while (sc.hasNext()){

            int n = sc.nextInt();
            int[][] dp = new int[n][n];
            dp[0][0] = sc.nextInt();
            long max = dp[0][0];
            for (int i = 1; i < n; i++) {
                for (int j = 0; j <= i; j++) {
                    int num = sc.nextInt();
                    if(j == 0)
                        dp[i][j] = dp[i-1][j] + num;
                    else
                        dp[i][j] = Math.max(dp[i-1][j-1],dp[i-1][j]) + num;
                    max = Math.max(dp[i][j],max);
                }

            }

            System.out.println(max);
        }

        sc.close();
    }

}

```



##### 02、编辑距离

编辑距离，又称Levenshtein距离（也叫做Edit Distance），是指两个字串之间，由一个转成另一个所需的最少编辑操作次数。许可的编辑操作包括将一个字符替换成另一个字符，插入一个字符，删除一个字符。 
例如将kitten一字转成sitting： 
sitten （k->s） 
sittin （e->i） 
sitting （->g） 
所以kitten和sitting的编辑距离是3。俄罗斯科学家Vladimir Levenshtein在1965年提出这个概念。 
给出两个字符串a,b，求a和b的编辑距离。

状态定义:Fi,j表示第一个字符串的前i个字母和第二个字符串的前j个字母需要编辑的次数，求Fn,m，n和m分别是两个字符串的长度。

状态转移方程： 
当Fi,j-1=Fi-1,j时，Fi,j=Fi,j-1； 
当Fi,j-1！=Fi-1,j时，Fi,j=min{Fi-1,j-1,Fi,j-1,Fi-1,j}+1.

```java
import java.util.Scanner;

public class Dp02 {

    /**
     * 编辑距离
     */
    public static void main(String[] args) {

        Scanner sc = new Scanner(System.in);
        while (sc.hasNext()) {

            dp02(sc.nextLine(), sc.nextLine());
        }

        sc.close();
    }

    public static void dp02(String s1, String s2) {

        int[][] dp = new int[s1.length() + 1][s2.length() + 1];
        dp[0][0] = 0;
        for (int i = 1; i < dp.length; i++) {

            dp[i][0] = i;
        }

        for (int i = 0; i < dp[0].length; i++) {

            dp[0][i] = i;
        }

        for (int a = 1; a < dp.length; a++) {

            for (int b = 1; b < dp[0].length; b++) {

                int c = 1;
                if (s1.charAt(a - 1) == s2.charAt(b - 1))
                    c = 0;
                dp[a][b] = Math.min(dp[a - 1][b - 1] + c, Math.min(dp[a - 1][b] + 1, dp[a][b - 1] + 1));
            }

        }

        System.out.println(dp[s1.length()][s2.length()]);
    }

}

```



##### 03、矩阵取数问题

一个N*N矩阵中有不同的正整数，经过这个格子，就能获得相应价值的奖励，从左上走到右下，只能向下向右走，求能够获得的最大价值。例如：3 * 3的方格。

1 3 3 
2 1 3 
2 2 1

能够获得的最大价值为：11。

```java
import java.util.Scanner;

public class Dp03 {

    /**
     * 矩阵取数问题
     */
    public static void main(String[] args) {

        Scanner sc = new Scanner(System.in);
        while (sc.hasNext()){

            int n = sc.nextInt();
            int[][] dp = new int[n][n];
            for (int a = 0; a < dp.length; a++) {

                for (int b = 0; b < dp[0].length; b++) {

                    int num = sc.nextInt();
                    if(a == 0 && b == 0){
                        dp[a][b] = num;
                    }else if(a == 0 && b > 0){
                        dp[a][b] = dp[a][b-1] + num;
                    }else if(a > 0 && b == 0){
                        dp[a][b] = dp[a-1][b] + num;
                    }else {
                        dp[a][b] = Math.max(dp[a-1][b],dp[a][b-1]) + num;
                    }

                }

            }

            System.out.println(dp[n-1][n-1]);
        }

        sc.close();
    }

}
```



##### 04、背包问题

 在N件物品取出若干件放在容量为W的背包里，每件物品的体积为W1，W2……Wn（Wi为整数），与之相对应的价值为P1,P2……Pn（Pi为整数）。求背包能够容纳的最大价值。 

```java
import java.util.Scanner;

public class Dp04 {

    /**
     * 背包问题
     */
    public static void main(String[] args) {

        Scanner sc = new Scanner(System.in);

        while (sc.hasNext()) {

            int n = sc.nextInt();
            int v = sc.nextInt();
            int[] dp = new int[v + 1];
            int[] price = new int[n + 1];
            int[] weight = new int[n + 1];
            long max = 0;
            for (int i = 0; i < n + 1; i++) {
                for (int j = v; j > 0; j--) {
                    if (j - weight[i] > 0)
                        dp[j] = Math.max(dp[j], dp[j - weight[i]] + price[i]);
                    else
                        dp[j] = dp[i];
                }

            }

            for (int i = 0; i < v + 1; i++) {

                max = max > dp[i] ? max : dp[i];
            }

            System.out.println(max);
        }

        sc.close();
    }
}
```



##### 05、最长递增子序列

 给出长度为N的数组，找出这个数组的最长递增子序列。 
(递增子序列是指，子序列的元素是递增的） 
例如：5 1 6 8 2 4 5 10，最长递增子序列是1 2 4 5 10。 

```java
import java.util.Arrays;
import java.util.Scanner;

public class Dp05 {

    /**
     * 最长递增子序列
     */
    public static void main(String[] args) {

        Scanner sc = new Scanner(System.in);
        while (sc.hasNext()) {

            int n = sc.nextInt();
            int[] arr = new int[n];
            for (int i = 0; i < n; i++) {

                arr[i] = sc.nextInt();
            }
            dp05(arr);
        }

        sc.close();
    }

    public static void dp05(int[] arr) {

        int[] dp = new int[arr.length];
        for (int i = 0; i < dp.length; i++) {

            dp[i] = 1;
            for (int j = 0; j < i; j++) {

                if (arr[i] > arr[j]) {
                    dp[i] = Math.max(dp[i], dp[j] + 1);
                }

            }

        }

        Arrays.sort(dp);
        System.out.println(dp[dp.length - 1]);
    }

}
```



##### 06、最大子段和

 N个整数组成的序列a[1],a[2],a[3],…,a[n]，求该序列如a[i]+a[i+1]+…+a[j]的连续子段和的最大值。 
当所给的整数均为负数时和为0。 
例如：-2,11,-4,13,-5,-2，和最大的子段为：11,-4,13。和为20。 

```java
import java.util.Scanner;

public class Dp06 {

    /**
     * 最大连续子串和
     */
    public static void main(String[] args) {

        Scanner sc = new Scanner(System.in);

        while (sc.hasNext()) {

            int n = sc.nextInt();
            int[] arr = new int[n];
            for (int i = 0; i < n; i++) {
                arr[i] = sc.nextInt();
            }

            dp06(arr);
        }

        sc.close();
    }

    public static void dp06(int[] arr) {

        int maxSum = Integer.MIN_VALUE;
        int nowSum = 0;
        for (int i : arr) {

            nowSum = nowSum + i;
            if (nowSum > maxSum)
                maxSum = nowSum;
            if (nowSum < 0)
                nowSum = 0;
        }

        System.out.println(maxSum);
    }

}
```



##### 07、最长公共子序列Lcs

给出两个字符串A B，求A与B的最长公共子序列（子序列不要求是连续的）。 
比如两个串为：

abcicba 
abdkscab

ab是两个串的子序列，abc也是，abca也是，其中abca是这两个字符串最长的子序列。

```java
import java.util.Scanner;

public class Dp07 {

    public static void main(String[] args) {

        /**
         * 最长公共子序列Lcs
         */
        Scanner sc = new Scanner(System.in);
        while (sc.hasNext()) {

            String s1 = sc.nextLine();
            String s2 = sc.nextLine();

            //最长公共子序列Lcs
            dp07(s1, s2);
        }

        sc.close();
    }


    public static void dp07(String s1, String s2) {

        int[][] dp = new int[s1.length() + 1][s2.length() + 1];
        dp[0][0] = 0;
        for (int i = 1; i < dp.length; i++) {
            dp[i][0] = 0;
        }

        for (int i = 0; i < dp[0].length; i++) {
            dp[0][i] = 0;
        }

        for (int a = 1; a < dp.length; a++) {

            for (int b = 1; b < dp[0].length; b++) {

                int c = 0;
                if (s1.charAt(a - 1) == s2.charAt(b - 1))
                    c = 1;
                dp[a][b] = Math.max(dp[a - 1][b - 1] + c, Math.max(dp[a - 1][b], dp[a][b - 1]));
            }
        }

        System.out.println(dp[s1.length()][s2.length()]);
    }
}
```



##### 08、正整数分组

 将一堆正整数分为2组，要求2组的和相差最小。 
例如：1 2 3 4 5，将1 2 4分为1组，3 5分为1组，两组和相差1，是所有方案中相差最少的。 

```java
import java.util.Scanner;

public class Dp08 {

    /**
     * 正整数分组要求两组差最小
     */
    public static void main(String[] args) {

        Scanner sc = new Scanner(System.in);
        while (sc.hasNext()) {

            int n = sc.nextInt();
            long sum = 0;
            int max = 0;
            int[] nums = new int[n];

            for (int i = 0; i < n; i++) {
                nums[i] = sc.nextInt();
                sum += nums[i];
            }

            int[] dp = new int[(int) (sum / 2 + 1)];
            for (int i = 0; i < n; i++) {
                for (int j = (int) (sum / 2); j > 0; j--) {
                    if (j >= nums[i]) {
                        dp[j] = Math.max(dp[j], dp[j - nums[i]] + nums[i]);
                    }
                }
            }

            //获取数据的大小
            for (int i = 1; i < sum / 2 + 1; i++) {
                max = max > dp[i] ? max : dp[i];
            }
            System.out.println(Math.abs((sum - max) - max));
        }
        sc.close();
    }
}
```

### 三、贪心算法

