{"./":{"url":"./","title":"README","keywords":"","body":"01_git git add . git commit -m 'all' git push origin master 02_gitbook 03_markdown04_gitbook常用插件 插件book.json { \"plugins\": [ \"back-to-top-button\", \"chapter-fold\", \"code\", \"splitter\", \"-lunr\", \"-search\", \"search-pro\", \"insert-logo\", \"custom-favicon\", \"pageview-count\", \"tbfed-pagefooter\", \"popup\", \"-sharing\", \"sharing-plus\" ], \"pluginsConfig\": { \"insert-logo\": { \"url\": \"https://file.smallzhiyun.com/%E4%B9%A6.png\", \"style\": \"background: none; max-height: 30px; min-height: 30px\" }, \"favicon\": \"./icon/book.ico\", \"tbfed-pagefooter\": { \"copyright\": \"Copyright &copy dsx2016.com 2019\", \"modify_label\": \"该文章修订时间：\", \"modify_format\": \"YYYY-MM-DD HH:mm:ss\" }, \"sharing\": { \"douban\": true, \"facebook\": true, \"google\": true, \"pocket\": true, \"qq\": true, \"qzone\": true, \"twitter\": true, \"weibo\": true, \"all\": [ \"douban\", \"facebook\", \"google\", \"instapaper\", \"linkedin\", \"twitter\", \"weibo\", \"messenger\", \"qq\", \"qzone\", \"viber\", \"whatsapp\" ] } } } gitbookUtil import com.sun.scenario.effect.impl.sw.sse.SSEBlend_SRC_OUTPeer; import java.io.File; import java.io.IOException; public class FileDemo { public static void main(String[] args) throws IOException { String dirPath = \"C:\\\\Users\\\\shanpd\\\\Desktop\\\\book\\\\_book\"; //String dirPath = \"C:\\\\Users\\\\shanpd\\\\Desktop\\\\book\\\\01_git\"; File dir = new File(dirPath); getFileList(dir); } //获取文件夹下面的所有文件 public static void getFileList(File dir) throws IOException { File[] files = dir.listFiles(); for (int i = 0;i \"+ files[i].getName() + \"\"); } } } } Copyright © dsx2016.com 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-04-02 22:11:14 "},"1.1_env.html":{"url":"1.1_env.html","title":"1、工作","keywords":"","body":"一、linux linux 三剑客 1、版本：VMwareworkstation_full_12.1.0.2487.1453173744.exe，key:UU148-6VF44-M80JY-YYMQV-WF89D 2、centos7 3、安装（只是安装自己玩没有必要分区） 命令行设置 #打开以下文件 vi /etc/sysconfig/network-scripts/ifcfg-ens33 #将文件中的ONBOOT改成yes #保存后执行以下命令： service network restart ip addr 永久关闭防火墙 systemctl disable firewalld.service linux常用命令 4. linux常用指令介绍 4.1. 文件目录操作命令 ls 显示文件和目录列表 　 -l 列出文件的详细信息 -a 列出当前目录所有文件，包含隐藏文件 mkdir 创建目录 　 -p 父目录不存在情况下先生成父目录 cd 切换目录 touch 生成一个空文件 echo 生成一个带内容文件 echo abcd>a.txt cat、tac 显示文本文件内容 cp 复制文件或目录 rm 删除文件 -r 同时删除该目录下的所有文件 -f 强制删除文件或目录 删除文件夹 rmdir 文件夹不能为空 删除文件夹 rm -rf 目录名字-r 就是向下递归，不管有多少级目录，一并删除-f 就是直接强行删除，不作任何提示的意思 mv 移动文件或目录、文件 mv aaa bbb 将aaa改名为bbb find 在文件系统中查找指定的文件 -name 文件名 wc 统计文本文档的行数，字数，字符数 grep 在指定的文本文件中查找指定的字符串 rmdir 删除空目录 tree 显示目录目录改名树 pwd 显示当前工作目录 ln 建立链接文件 more、less 分页显示文本文件内容 head,tail分别显示文件开头和结尾内容 tar -zcvf a.tar.gz a.txt tar -zxvf a.tar.gz wget curl 4.2. 系统管理命令 stat 显示指定文件的相关信息,比ls命令显示内容更多 who 显示在线登录用户 hostname 显示主机名称 uname显示系统信息 d top 显示当前系统中耗费资源最多的进程 ps 显示瞬间的进程状态 du 显示指定的文件（目录）已使用的磁盘空间的总量 df 显示文件系统磁盘空间的使用情况 free 显示当前内存和交换空间的使用情况 ifconfig 显示网络接口信息 ping 测试网络的连通性 netstat 显示网络状态信息 man 命令帮助信息查询 clear 清屏 kill 杀死一个进程 tcpdump -s O -l -i any -w -port 8080 | string 四剑客 1、grep -C 'abc' a.txt 2、 find指令用于查找符合条件的文件 示例： find / -name “ins*” 查找文件名称是以ins开头的文件 find / -name “ins*” –ls find / –user itcast –ls 查找用户itcast的文件 find / –user itcast –type d –ls 查找用户itcast的目录 find /-perm -777 –type d-ls 查找权限是777的文件 3、sed(spd/cai)增删改查(-i参数保存到原文件) sed -n '1p' sed.txt sed -n '1,5p' sed.txt sed -n '/2:00/p' sed.txt sed -n '/2:00/,/3:00/p' sed.txt sed -n '1d' sed.txt sed -n '1,5d' sed.txt sed -n '/2:00/d' sed.txt sed -n '/2:00/,/3:00/d' sed.txt sed -n 's/^west/north/gp' sed.txt 第一行和最后一行添加内容 sed -n 'i abc' sed.txt sed -n '$a abc' sed.txt 五、循环语句 #!/bin/bash # while IFS='=' while read site sitedomain do weget ${sitedomain --no-check-certficate -O /dev/null -o /home/spd/hosting/log/${site}}.log done 二、安装docker 1、卸载旧的版本 yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine 2、安装需要的安装包 yum install -y yum-utils 3、设置镜像仓库 yum-config-manager \\ --add-repo \\ http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo # 百度搜的阿里云镜像 4、更新yum包的索引 yum makecache fast # CentOS 7使用此命令 yum makecache # CentOS 8使用此命令 5、安装docker yum install docker-ce docker-ce-cli containerd.io 7、查看安装docker的版本 docker -v 6、启动docker systemctl start docker systemctl restart docker systemctl stop docker 8、使用阿里云镜像加速 查看不回加速的配置文件 [root@localhost ~]# cat /etc/docker/daemon.json { \"registry-mirrors\": [\"https://m3e4jmm0.mirror.aliyuncs.com\"] } 配置阿里加速 sudo mkdir -p /etc/docker sudo tee /etc/docker/daemon.json 三、安装mysql 1、查看镜像mysql docker search mysql 2、下载对应的mysql版本 docker pull mysql:5.6 3、查看下载的镜像 docker images 4、安装mysql（-v是数据卷本地目录映射到容器中的目录） # 在/root目录下创建mysql目录用于存储mysql数据信息 mkdir ~/mysql cd ~/mysql #安装 docker run -id \\ -p 3306:3306 \\ --name=mysql \\ -v $PWD/conf:/etc/mysql/conf.d \\ -v $PWD/logs:/logs \\ -v $PWD/data:/var/lib/mysql \\ -e MYSQL_ROOT_PASSWORD=root \\ mysql:5.6 5、查看安装好的mysql进行 docker ps | grep mysql 6、进入安装好的msyql容器 docker exec -it mysql bash 7、登录mysql mysql -h localhost -u root -proot 8、查看mysql的数据库 show databases; 6、常用sql CREATE DATABASE spd; SHOW DATABASES; USE spd; DROP DATABASE spd; CREATE TABLE student( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(10), age VARCHAR(10) ); SHOW TABLES; SHOW CREATE TABLE student; DROP TABLE student; ALTER TABLE student ADD image VARCHAR(20); ALTER TABLE student MODIFY image VARCHAR(40); ALTER TABLE student DROP image; RENAME TABLE student TO employee; INSERT INTO student(NAME,age) VALUES('张三','13'); SELECT * FROM student; UPDATE employee SET age=14 WHERE id = 1; DELETE FROM student WHERE id = 1; DROP TABLE student; TRUNCATE student; -- select ... from ... where ... group by... having... order by ... limit; CREATE TABLE orders( id INT, product VARCHAR(20), price FLOAT ); INSERT INTO orders(id,product,price) VALUES(1,'电视',900); INSERT INTO orders(id,product,price) VALUES(2,'洗衣机',100); INSERT INTO orders(id,product,price) VALUES(3,'洗衣粉',90); INSERT INTO orders(id,product,price) VALUES(4,'桔子',9); INSERT INTO orders(id,product,price) VALUES(5,'洗衣粉',90); INSERT INTO orders(id,product,price) VALUES(6,'电视',900); USE day16; CREATE TABLE dept( did INT PRIMARY KEY AUTO_INCREMENT, dname VARCHAR(30) ); CREATE TABLE emp( eid INT PRIMARY KEY AUTO_INCREMENT, ename VARCHAR(20), salaly DOUBLE, dno INT ); SHOW TABLES; INSERT INTO dept VALUES(NULL,'研发部'); INSERT INTO dept VALUES(NULL,'销售部'); INSERT INTO dept VALUES(NULL,'人事部'); INSERT INTO dept VALUES(NULL,'扯淡部'); INSERT INTO dept VALUES(NULL,'牛宝宝部'); INSERT INTO emp VALUES(NULL,'班长',10000,1); INSERT INTO emp VALUES(NULL,'美美',10000,2); INSERT INTO emp VALUES(NULL,'小凤',10000,3); INSERT INTO emp VALUES(NULL,'如花',10000,2); INSERT INTO emp VALUES(NULL,'芙蓉',10000,1); INSERT INTO emp VALUES(NULL,'东东',800,NULL); INSERT INTO emp VALUES(NULL,'波波',1000,NULL); ALTER TABLE emp ADD FOREIGN KEY emp(dno) REFERENCES dept(did); SELECT * FROM dept; SELECT * FROM emp; * 添加外键 语法：alter table emp add foreign key 当前表名(dno) references 关联的表(did); alter table emp add foreign key emp(dno) references dept(did); SELECT * FROM dept,emp WHERE dept.did=emp.dno; SELECT * FROM dept INNER JOIN emp ON dept.did=emp.dno; SELECT * FROM dept LEFT JOIN emp ON dept.did=emp.dno; SELECT * FROM dept RIGHT JOIN emp ON dept.did=emp.dno; SELECT * FROM emp; SELECT * FROM emp LIMIT 2,4; SELECT * FROM emp ORDER BY salaly DESC; SELECT * FROM emp ORDER BY salaly ASC; -- select product,sum(price) from orders group by product having sum(price) > 100; -- select ... from ... where ... group by... having... order by ... limit; 四、安装tomcat 一、拉取镜像文件 docker pull tomcat #最新版本的tomcat 二、查看拉取的文件 docker images 三、安装镜像文件（-v是数据卷本地目录映射到容器中的目录） docker run -id --name=tomcat \\ -p 8080:8080 \\ -v $PWD:/usr/local/tomcat/webapps \\ tomcat 二、访问tomcat http://192.168.188.130:8080/webapps/index.html 五、安装nginx 三、部署Nginx 1. 搜索nginx镜像 2. 拉取nginx镜像 3. 创建容器，设置端口映射、目录映射 docker search nginx docker pull nginx # 在/root目录下创建nginx目录用于存储nginx数据信息 mkdir ~/nginx cd ~/nginx mkdir conf cd conf # 在~/nginx/conf/下创建nginx.conf文件,粘贴下面内容 vim nginx.conf user nginx; worker_processes 1; error_log /var/log/nginx/error.log warn; pid /var/run/nginx.pid; events { worker_connections 1024; } http { include /etc/nginx/mime.types; default_type application/octet-stream; log_format main '$remote_addr - $remote_user [$time_local] \"$request\" ' '$status $body_bytes_sent \"$http_referer\" ' '\"$http_user_agent\" \"$http_x_forwarded_for\"'; access_log /var/log/nginx/access.log main; sendfile on; #tcp_nopush on; keepalive_timeout 65; #gzip on; include /etc/nginx/conf.d/*.conf;: } 安装 docker run -id --name=nginx \\ -p 80:80 \\ -v $PWD/conf/nginx.conf:/etc/nginx/nginx.conf \\ -v $PWD/logs:/var/log/nginx \\ -v $PWD/html:/usr/share/nginx/html \\ nginx 参数说明： -p 80:80：将容器的 80端口映射到宿主机的 80 端口。 -v $PWD/conf/nginx.conf:/etc/nginx/nginx.conf：将主机当前目录下的 /conf/nginx.conf 挂载到容 器的 :/etc/nginx/nginx.conf。配置目录 -v $PWD/logs:/var/log/nginx：将主机当前目录下的 logs 目录挂载到容器的/var/log/nginx。日志目 录 4. 使用外部机器访问nginx http://192.168.188.130/index.html 六、安装redis 1、查找镜像redis docker search redis 2、拉取redis docker pull redis 3、查看拉取的redis docker images 4、安装redis docker run -id --name=redis -p 6379:6379 redis:5.0 5、外部机器连接redis ./redis-cli.exe -h 192.168.149.135 -p 6379 七、dockerfile 1、编写docker_file文件 FROM JAVA:8 MAINTAINER shanpd ADD springboot-hello-0.0.1-SNAPSHOT.jar app.jar CDM java -jar app.jar 2、构建镜像文件 docker build -f ./spingboot_docker -t app . 3、创建sprintboot的docker容器 docker run -id --name=app -p 9090:8080 app 4、访问springboot 服务 http://192.168.188.130:9090/hello 5、docker_compose DockerCompose是一个编排多容器分布式部署的工具，提供命令集管理容器化应用的完整开发周期，包括构建，启动和停止，使用步骤 1、利用Dockerfile定义支行环境镜像 2、使用docker-compose.yml定义组成应用的各服务 3、支行docker-compose up 启动应用 一、安装Docker Compose # Compose目前已经完全支持Linux、Mac OS和Windows，在我们安装Compose之前，需要先安装Docker。下面我 们以 编译好的二进制包方式安装在Linux系统中。 curl ‐L https://github.com/docker/compose/releases/download/1.22.0/docker‐compose‐`uname ‐s`‐ `uname ‐m` ‐o /usr/local/bin/docker‐compose # 设置文件可执行权限 chmod +x /usr/local/bin/docker‐compose # 查看版本信息 docker‐compose ‐version 二、卸载Docker Compose # 二进制包方式安装的，删除二进制文件即可 rm /usr/local/bin/docker‐compose 三、 使用docker compose编排nginx+springboot项目 1. 创建docker-compose目录 mkdir ~/docker‐compose cd ~/docker‐compose 2. 编写 docker-compose.yml 文件 version: '3' services: nginx: image: nginx ports: ‐ 80:80 links: ‐ app volumes: ‐ ./nginx/conf.d:/etc/nginx/conf.d app: image: app expose: ‐ \"8080\" 3. 创建./nginx/conf.d目录 mkdir ‐p ./nginx/conf.d 4. 在./nginx/conf.d目录下 编写itheima.conf文件 server { listen 80; access_log off; location / { proxy_pass http://app:8080; } } 5. 在~/docker-compose 目录下 使用docker-compose 启动容器 docker‐compose up 6. 测试访问 http://192.168.149.135/hello Copyright © dsx2016.com 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-14 18:14:57 "},"1.2_mysql.html":{"url":"1.2_mysql.html","title":"1.2、mysql","keywords":"","body":"Copyright © dsx2016.com 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-04-05 22:44:26 "},"1.3_java.html":{"url":"1.3_java.html","title":"1.3、java","keywords":"","body":"java Day01 (Java概述) .pdf Day02 (基础语法 ).pdf Day03 (基础语法) .pdf Day04 (基础语法) .pdf Day05 (基础语法）.pdf Day06 (面向对象) .pdf Day07 (面向对象) .pdf Day08（继承）.pdf Day09（继承）.pdf Day10（继承）.pdf Day11（继承）.pdf Day12 (多线程) .pdf Day13 (多线程) .pdf Day14（多线程 ) .pdf Day15（集合 ）.pdf Day16（集合 ）.pdf Day17（集合 ）.pdf Day18（集合 ）.pdf Day19（集合 ）.pdf Day20（ IO ）.pdf Day21（ IO ）.pdf Day22（ IO ）.pdf Day23（ IO ）.pdf Day24（ IO ）.pdf Day25 (网络编程) .pdf Day26 (网络编程) .pdf Day27 (反射+正则）.pdf Day28（Lamdba&方法引用）.pdf Day29（函数式接口&Stream流）.pdf Day30（类加载器&反射&模块化）.pdf Day31_2020最新Java面试题及答案.pdf javaWeb day01_基础加强.pdf day01_基础加强2.pdf day02_MySQL基础.pdf day03_MySQL约束.pdf day04_MySQL多表&事务.pdf day05_JDBC.pdf day06_JDBC连接池&JDBCTemplate.pdf day07_HTML.pdf day08_HTML&CSS.pdf day09_javaScript基础.pdf day10_javaScript高级.pdf day11_BootStrap.pdf day12-Xml.pdf day13_Tomcat&Servlet.pdf day14_Servlet&HTTP&Request.pdf day15_Response.pdf day16_Cookie&Session.pdf day17_EL&JSTL.pdf day18_综合练习.pdf day19_Filter&Listener.pdf day20_JQuery基础.pdf day21_JQuery高级.pdf day22_Ajax&Json.pdf day23_redis.pdf day24_maven基础.pdf springboot 01_springbook.pdf docker 01_docker安装.pdf 02_docker应用部署.pdf 03_dockerfile.pdf 04_docker-compose.pdf 05_docker 私有仓库.pdf _web index.html Copyright © dsx2016.com 2023 all right reserved，powered by Gitbook该文章修订时间： 2022-10-29 19:07:50 "},"1.4_python.html":{"url":"1.4_python.html","title":"1.4、python","keywords":"","body":"python_day01_02.pdf python_day03_04.pdf python_day05_06.pdf python_day07.pdf python_pandas.pdf python_pandas_begin.pdf python_pandas_select.pdf python_pandas_time.pdf Copyright © dsx2016.com 2023 all right reserved，powered by Gitbook该文章修订时间： 2022-06-05 11:27:43 "},"1.5_testTheory.html":{"url":"1.5_testTheory.html","title":"1.5、testTheory","keywords":"","body":"一、vm+linux+docker+mysql+tomcat+nginx+rdies 二、 base 三、python python_day01_02.pdf python_day03_04.pdf python_day05_06.pdf python_day07.pdf python_pandas.pdf python_pandas_begin.pdf python_pandas_select.pdf python_pandas_time.pdf 四、web index.html 五、api index.html 六、app 七、per 八、offer 测试方法 1、等价类 2、边界值 3、因果图 4、判定表 5、场景法 6、流程法 7、错误推断 8、排列组合(3*4*3)->正交表（使用最小的测试过程集合获得最大的测试覆盖率）->混合正交表(因子数不一样) 全面试验中挑选有代表性的点进行测试(均匀分散，整齐可比)：高效率，快整，经济 Copyright © dsx2016.com 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-03-30 23:00:36 "},"1.6_workNotes.html":{"url":"1.6_workNotes.html","title":"1.6、workNotes","keywords":"","body":"一、性能指标 1、硬件要求 2、软件要求 3、测试组网 4、性能指标 1、系统性能指标 响应时间 系统处理能力 吞吐量 并发用户数 错误率 2、资源性能指标 CPU 内存 磁盘吞吐量 网络吞吐量 二、测试方法 1、覆盖所有改造参数(正向) 2、组合可行参数(正向——覆盖率的问题，考虑人力和时间成本) 3、参数边界(比如年龄边界) 4、如果参数的取范围是枚举，需要覆盖所有的枚举值(测试所有可能数据) 5、空数据(逆向_不录入数据) 6、包含特殊字符(逆向_+-*/=&*_) 7、越界数据(逆向_比如长度太大或太短) 8、错误数据(逆向_比如错误的手机号，身份证，重复的ID) 异常场景校验 1、越权验证：比如不存在 2、状态验证：比如siteid状态为非上线状态 3、限制验证：比如siteid个数限制 4、重复验证相同数据： 5、交叉认证： 一、兼容性 内容兼容：删除版本是否把这个版本添加的表数据删除 页面兼容：升级时新的页面兼容老的后台数据 浏览器兼容： 二、国际化 1、场景法 2、流程法 3、等价类 4、边界值 5、因果图和判定表 6、正交排列组合 7、补充和错误推导 三、linux三剑客 一、正则 二、grep（A,B,C,c） 1、过滤 三、sed(-i保存在文件)---spd/cai(替换，查找，删除，添加)：找认证做啥 1、查找 -n '/1,2p/p' a.txt -n '/101/,/105/p' a.txt 2、删除 -n '/1,2p/p' a.txt -n '/101/,/105/p' a.txt 3、新增 -n '/$a abc/' a.txt 4、替换 -n 's/a/b/g' a.txt 四、awk（取列，统计，计算）修改变量 --v OFS == : -F 'BEGIN{}条件{}END{}' a.txt 五、其它(制表符，命令说明，统计数量) column -t info wc -l 四、抓包、 tcpdump -s O -l -i any -w -port 8080 | string 五、常用命令 #!/bin/bash # while IFS='=' while read site sitedomain do weget ${sitedomain --no-check-certficate -O /dev/null -o /home/spd/hosting/log/${site}}.log done Copyright © dsx2016.com 2023 all right reserved，powered by Gitbook该文章修订时间： 2022-10-29 23:48:50 "},"1.7_huawei.html":{"url":"1.7_huawei.html","title":"1.7、huawei","keywords":"","body":"算法 一、分而冶之 二、动态规划 01、 数塔取数问题 一个高度为N的由正整数组成的三角形，从上走到下，求经过的数字和的最大值。 每次只能走到下一层相邻的数上，例如从第3层的6向下走，只能走到第4层的2或9上。 该三角形第n层有n个数字，例如： 第一层有一个数字：5 第二层有两个数字：8 4 第三层有三个数字：3 6 9 第四层有四个数字：7 2 9 5 最优方案是：5 + 8 + 6 + 9 = 28 注意:上面应该是排列成一个三角形的样子不是竖向对应的，排版问题没有显示成三角形。 状态定义: Fi，j是第i行j列项最大取数和，求第n行Fn，m（0 状态转移方程：Fi，j = max{Fi-1,j-1,Fi-1,j}+Ai,jt import java.util.Scanner; public class Dp01 { /** * 数塔取数问题 */ public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()){ int n = sc.nextInt(); int[][] dp = new int[n][n]; dp[0][0] = sc.nextInt(); long max = dp[0][0]; for (int i = 1; i 02、编辑距离 编辑距离，又称Levenshtein距离（也叫做Edit Distance），是指两个字串之间，由一个转成另一个所需的最少编辑操作次数。许可的编辑操作包括将一个字符替换成另一个字符，插入一个字符，删除一个字符。 例如将kitten一字转成sitting： sitten （k->s） sittin （e->i） sitting （->g） 所以kitten和sitting的编辑距离是3。俄罗斯科学家Vladimir Levenshtein在1965年提出这个概念。 给出两个字符串a,b，求a和b的编辑距离。 状态定义:Fi,j表示第一个字符串的前i个字母和第二个字符串的前j个字母需要编辑的次数，求Fn,m，n和m分别是两个字符串的长度。 状态转移方程： 当Fi,j-1=Fi-1,j时，Fi,j=Fi,j-1； 当Fi,j-1！=Fi-1,j时，Fi,j=min{Fi-1,j-1,Fi,j-1,Fi-1,j}+1. import java.util.Scanner; public class Dp02 { /** * 编辑距离 */ public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()) { dp02(sc.nextLine(), sc.nextLine()); } sc.close(); } public static void dp02(String s1, String s2) { int[][] dp = new int[s1.length() + 1][s2.length() + 1]; dp[0][0] = 0; for (int i = 1; i 03、矩阵取数问题 一个NN矩阵中有不同的正整数，经过这个格子，就能获得相应价值的奖励，从左上走到右下，只能向下向右走，求能够获得的最大价值。例如：3 3的方格。 1 3 3 2 1 3 2 2 1 能够获得的最大价值为：11。 import java.util.Scanner; public class Dp03 { /** * 矩阵取数问题 */ public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()){ int n = sc.nextInt(); int[][] dp = new int[n][n]; for (int a = 0; a 0){ dp[a][b] = dp[a][b-1] + num; }else if(a > 0 && b == 0){ dp[a][b] = dp[a-1][b] + num; }else { dp[a][b] = Math.max(dp[a-1][b],dp[a][b-1]) + num; } } } System.out.println(dp[n-1][n-1]); } sc.close(); } } 04、背包问题 在N件物品取出若干件放在容量为W的背包里，每件物品的体积为W1，W2……Wn（Wi为整数），与之相对应的价值为P1,P2……Pn（Pi为整数）。求背包能够容纳的最大价值。 import java.util.Scanner; public class Dp04 { /** * 背包问题 */ public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()) { int n = sc.nextInt(); int v = sc.nextInt(); int[] dp = new int[v + 1]; int[] price = new int[n + 1]; int[] weight = new int[n + 1]; long max = 0; for (int i = 0; i 0; j--) { if (j - weight[i] > 0) dp[j] = Math.max(dp[j], dp[j - weight[i]] + price[i]); else dp[j] = dp[i]; } } for (int i = 0; i dp[i] ? max : dp[i]; } System.out.println(max); } sc.close(); } } 05、最长递增子序列 给出长度为N的数组，找出这个数组的最长递增子序列。 (递增子序列是指，子序列的元素是递增的） 例如：5 1 6 8 2 4 5 10，最长递增子序列是1 2 4 5 10。 import java.util.Arrays; import java.util.Scanner; public class Dp05 { /** * 最长递增子序列 */ public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()) { int n = sc.nextInt(); int[] arr = new int[n]; for (int i = 0; i arr[j]) { dp[i] = Math.max(dp[i], dp[j] + 1); } } } Arrays.sort(dp); System.out.println(dp[dp.length - 1]); } } 06、最大子段和 N个整数组成的序列a[1],a[2],a[3],…,a[n]，求该序列如a[i]+a[i+1]+…+a[j]的连续子段和的最大值。 当所给的整数均为负数时和为0。 例如：-2,11,-4,13,-5,-2，和最大的子段为：11,-4,13。和为20。 import java.util.Scanner; public class Dp06 { /** * 最大连续子串和 */ public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()) { int n = sc.nextInt(); int[] arr = new int[n]; for (int i = 0; i maxSum) maxSum = nowSum; if (nowSum 07、最长公共子序列Lcs 给出两个字符串A B，求A与B的最长公共子序列（子序列不要求是连续的）。 比如两个串为： abcicba abdkscab ab是两个串的子序列，abc也是，abca也是，其中abca是这两个字符串最长的子序列。 import java.util.Scanner; public class Dp07 { public static void main(String[] args) { /** * 最长公共子序列Lcs */ Scanner sc = new Scanner(System.in); while (sc.hasNext()) { String s1 = sc.nextLine(); String s2 = sc.nextLine(); //最长公共子序列Lcs dp07(s1, s2); } sc.close(); } public static void dp07(String s1, String s2) { int[][] dp = new int[s1.length() + 1][s2.length() + 1]; dp[0][0] = 0; for (int i = 1; i 08、正整数分组 将一堆正整数分为2组，要求2组的和相差最小。 例如：1 2 3 4 5，将1 2 4分为1组，3 5分为1组，两组和相差1，是所有方案中相差最少的。 import java.util.Scanner; public class Dp08 { /** * 正整数分组要求两组差最小 */ public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()) { int n = sc.nextInt(); long sum = 0; int max = 0; int[] nums = new int[n]; for (int i = 0; i 0; j--) { if (j >= nums[i]) { dp[j] = Math.max(dp[j], dp[j - nums[i]] + nums[i]); } } } //获取数据的大小 for (int i = 1; i dp[i] ? max : dp[i]; } System.out.println(Math.abs((sum - max) - max)); } sc.close(); } } 三、贪心算法 四、考试 001、【最大N个数与最小N个数的和】 给定一个数组，编写一个函数来计算它的最大N个数与最小N个数的和。你需要对数组进行去重。 说明： 数组中数字范围[0, 1000] 最大N个数与最小N个数不能有重叠，如有重叠，输入非法返回-1 *输入非法返回-1 输入描述： 输出描述： 示例1： 输入 5 95 88 83 64 100 2 输出 342 public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()) { int m = sc.nextInt(); int[] arr = new int[m]; for (int i = 0; i arr.length) return -1; Arrays.sort(arr); int minSum = 0; int maxSum = 0; for (int i = 0; i arr.length - 1 - n; i--) { maxSum += arr[i]; } return minSum + maxSum; } 002、【事件推送】 同一个数轴X上有两个点的集合A={A , A , …, A }和B={B , B , …, B }，A 和B 均为正整数，A、B已经按照从小到大排好序，A、B均不为空，给定一 个距离R(正整数)，列出同时满足如下条件的所有（A , B ）数对： 1）A public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()) { int m = sc.nextInt(); int n = sc.nextInt(); int r = sc.nextInt(); int[] arr1 = new int[m]; int[] arr2 = new int[n]; for (int i = 0; i = arr1[i] && arr2[j] - arr1[i] 003、【找车位】 停车场有一横排车位，0代表没有停车，1代表有车。至少停了一辆车在车位上，也至少有一个空位没有停车。 为了防剐蹭，需为停车人找到一个车位，使得距停车人的车最近的车辆的距离是最大的，返回此时的最大距离。 输入描述： 1、一个用半角逗号分割的停车标识字符串，停车标识为0或1，0为空位，1为已停车。 2、停车位最多100个。 输出描述： 输出一个整数记录最大距离。 示例1： 输入 1,0,0,0,0,1,0,0,1,0,1 输出 2 public static void sp02(String s) { String[] ss = s.split(\",\"); int[] dp = new int[ss.length]; int sum = 0; for (int i = 0; i 004、【磁盘容量排序】 磁盘的容量单位常用的有M，G，T这三个等级，它们之间的换算关系为1T = 1024G，1G = 1024M，现在给定n块磁盘的容量，请对它们按从小 到大的顺序进行稳定排序，例如给定5块盘的容量，1T，20M，3G，10G6T，3M12G9M排序后的结果为20M，3G，3M12G9M，1T，10G6T。注意单位可以重复 出现，上述3M12G9M表示的容量即为3M+12G+9M，和12M12G相等。 输入描述： 输入第一行包含一个整数n(2 public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()) { int n = sc.nextInt(); String[] arr = new String[n]; for (int i = 0; i list = new ArrayList<>(); for (int i : rec) { if (!list.contains(i)) list.add(i); } for (int i : list) { for (int j = 0; j 005、【数字涂色】 疫情过后，希望小学终于又重新开学了，三年二班开学第一天的任务是将后面的黑板报重新制作。黑板上已经写上了N个正整数，同学们需要给这每个 数分别上一种颜色。为了让黑板报既美观又有学习意义，老师要求同种颜色的所有数都可以被这种颜色中最小的那个数整除。现在请你帮帮小朋友们，算算最少需要 多少种颜色才能给这N个数进行上色。 输入描述： 第一行有一个正整数N，其中 。 第二行有N个int型数(保证输入数据在[1,100]范围中)，表示黑板上各个正整数的值。 输出描述： 输出只有一个整数，为最少需要的颜色种数 示例1： 输入 3 2 4 6 输出 1 342 public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()) { int n = sc.nextInt(); int[] arr = new int[n]; for (int i = 0; i list = new ArrayList<>(); list.add(arr[0]); for (int i = 1; i 006、【两数之和绝对值最小】 给定一个从小到大的有序整数序列（存在正整数和负整数）数组 nums ，请你在该数组中找出两个数，其和的绝对值(|nums[x]+nums[y]|) 为最小值，并返回这个绝对值。 每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。 输入描述： 一个通过空格分割的有序整数序列字符串，最多1000个整数，且整数数值范围是 -65535~65535。 输出描述： 两数之和绝对值最小值 示例1： 输入 -3 -1 5 7 11 15 输出 2 public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()) { String[] arr = sc.nextLine().split(\" \"); sp06(arr); } sc.close(); } public static void sp06(String[] arr) { int min = Integer.MAX_VALUE; for (int i = 0; i 007、【玩牌高手】 给定一个长度为n的整型数组，表示一个选手在n轮内可选择的牌面分数。选手基于规则选牌，请计算所有轮结束后其可以获得的最高总分数。选择规则如下： 1、在每轮里选手可以选择获取该轮牌面，则其总分数加上该轮牌面分数，为其新的总分数。 2、选手也可不选择本轮牌面直接跳到下一轮，此时将当前总分数还原为3轮前的总分数，若当前轮次小于等于3（即在第1、2、3轮选择跳过轮次），则总分数置为 0。 3、选手的初始总分数为0，且必须依次参加每一轮。 输入描述： 第一行为一个小写逗号分割的字符串，表示n轮的牌面分数，1 public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()) { String s = sc.nextLine(); sp07(s); } sc.close(); } public static void sp07(String s) { String[] arr = s.split(\",\"); int nowSum = 0, count = 0, sum_3 = 0; for (String s1 : arr) { nowSum += Integer.parseInt(s1); count++; if (nowSum = 4) { nowSum = sum_3; count = 3; } if (count == 3) { sum_3 = nowSum; } } System.out.println(nowSum); } 008、【考勤信息】 公司用一个字符串来表示员工的出勤信息： absent：缺勤 late：迟到 leaveearly：早退 present：正常上班 现需根据员工出勤信息，判断本次是否能获得出勤奖，能获得出勤奖的条件如下： 缺勤不超过一次；没有连续的迟到/早退；任意连续7次考勤，缺勤/迟到/早退不超过3次 输入描述： 用户的考勤数据字符串，记录条数 >= 1；输入字符串长度 public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()) { String[] arr = sc.nextLine().split(\" \"); System.out.println(sp08(arr)); } sc.close(); } public static boolean sp08(String[] arr) { int a = 0; for (int i = 0; i 1) return false; } for (int i = 0; i 3) return false; } } return true; } 009 服务失效判断 a8-a1,a1-a2,a5-a6,a2-a3 a5,a2 public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()) { String[] s1 = sc.nextLine().split(\",\"); String[][] ss = new String[s1.length][2]; for (int i = 0; i list = new ArrayList<>(); for (String s1 : s) { list.add(s1); } //这里有问题 for (int i = 0; i pass = new ArrayList<>(); for (int i = 0; i 010 、【字符匹配】 给你一个字符串数组（每个字符串均由小写字母组成）和一个字符规律（由小写字母和.和组成），识别数组中哪些字符串可以匹配到字符规律上。 '.' 匹配任意单个字符，'' 匹配零个或多个任意字符；判断字符串是否匹配，是要涵盖整个字符串的，而不是部分字符串。 输入描述： 第一行为空格分割的多个字符串，1 public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()) { String[] arr = sc.nextLine().split(\" \"); String reg = sc.nextLine(); sp10(arr, reg); } sc.close(); } public static void sp10(String[] arr, String reg) { for (int i = 0; i 011、【分苹果】 public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()) { int n = sc.nextInt(); int[] arr = new int[n]; for (int i = 0; i 012、打印机任务排序 public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()) { String[] arr = sc.nextLine().split(\",\"); sp12(arr); } sc.close(); } public static void sp12(String[] arr) { ArrayList list = new ArrayList<>(); for (String s : arr) { int temp = Integer.parseInt(s); if (!list.contains(temp)) list.add(temp); } Collections.sort(list); int count = 0; for (int a = list.size() - 1; a >= 0; a--) { for (int i = 0; i 013、【找朋友】 在学校中，N个小朋友站成一队， 第i个小朋友的身高为height[i]， 第i个小朋友可以看到的第一个比自己身高更高的小朋友j，那么j是i的好朋友(要求j > i)。 请重新生成一个列表，对应位置的输出是每个小朋友的好朋友位置，如果没有看到好朋友，请在该位置用0代替。 小朋友人数范围是 [0, 40000]。 输入描述： 第一行输入N，N表示有N个小朋友 第二行输入N个小朋友的身高height[i]，都是整数 输出描述： 输出N个小朋友的好朋友的位置 示例1： 输入 2 100 95 输出 0 0 public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()) { int n = sc.nextInt(); int[] arr = new int[n]; for (int i = 0; i 014、【寻找身高相近的小朋友】 小明今年升学到小学一年级，来到新班级后发现其他小朋友们身高参差不齐，然后就想基于各小朋友和自己的身高差对他们进行排序，请 帮他实现排序。 输入描述： 第一行为正整数H和N，0 public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()) { int h = sc.nextInt(); int n = sc.nextInt(); int[] arr = new int[n]; for (int i = 0; i list = new ArrayList(); for (int i : arr) { if (!list.contains(Math.abs(i - h))) list.add(Math.abs(i - h)); } Collections.sort(list); List rec = new ArrayList(); for (Integer integer : list) { List temp = new ArrayList(); for (int i : arr) { if (Math.abs(i - h) == integer) temp.add(i); } Collections.sort(temp); rec.addAll(temp); } for (Integer integer : rec) { System.out.print(integer + \" \"); } } 015、【数组组成的最小数字】 给定一个整型数组，请从该数组中选择3个元素组成最小数字并输出（如果数组长度小于3，则选择数组中所有元素来组成最小数字）。 输入描述： 一行用半角逗号分割的字符串记录的整型数组，0 public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()) { String[] arr = sc.nextLine().split(\",\"); System.out.println(sp16(arr)); } sc.close(); } public static int sp16(String[] arr) { int temp1 = 0, temp2 = 0, temp3 = 0; if (arr.length 016、【一种字符串压缩表示的解压】---未完成 有一种简易压缩算法：针对全部由小写英文字母组成的字符串，将其中连续超过两个相同字母的部分压缩为连续个数加该字母，其他 部分保持原样不变。例如：字符串“aaabbccccd”经过压缩成为字符串“3abb4cd”。 请您编写解压函数，根据输入的字符串，判断其是否为合法压缩过的字符 串，若输入合法则输出解压缩后的字符串，否则输出字符串“!error”来报告错误。 输入描述： 输入一行，为一个ASCII字符串，长度不会超过100字符，用例保证输出的字符串长度也不会超过100字符 输出描述： 若判断输入为合法的经过压缩后的字符串，则输出压缩前的字符串；若输入不合法，则输出字符串“!error”。 示例1： 输入 4dff 输出 ddddff public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()) { String s = sc.next(); sp17(s); } sc.close(); } public static void sp17(String s) { boolean matches = s.matches(\"[a-z0-9]*[a-z]$\"); System.out.println(matches); } 017、【乱序整数序列两数之和绝对值最小】 给定一个随机的整数（可能存在正整数和负整数）数组 nums ，请你在该数组中找出两个数，其和的绝对值 (|nums[x]+nums[y]|)为最小值，并返回这个两个数（按从小到大返回）以及绝对值。 每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。 输入描述： 一个通过空格分割的有序整数序列字符串，最多1000个整数，且整数数值范围是 [-65535, 65535]。 输出描述： 两数之和绝对值最小值 示例1： 输入 -1 -3 7 5 11 15 输出 -3 5 2 public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()) { String[] arr = sc.nextLine().split(\" \"); sp18(arr); } sc.close(); } public static void sp18(String[] arr) { long sum = 0; ArrayList list = new ArrayList<>(); for (int i = 0; i 018、【停车场车辆统计】 特定大小的停车场，数组cars[]表示，其中1表示有车，0表示没车。车辆大小不一，小车占一个车位（长度1），货车占两个车位（长度2），卡 车占三个车位（长度3），统计停车场最少可以停多少辆车，返回具体的数目。 输入描述： 整型字符串数组cars[]，其中1表示有车，0表示没车，数组长度小于1000。 输出描述： 整型数字字符串，表示最少停车数目。 示例1： 输入 1,0,1 输出 2 public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()) { String[] arr = sc.nextLine().split(\",\"); sp19(arr); } sc.close(); } private static void sp19(String[] arr) { int min = 0; int count = 0; for (int i = 0; i 019、【字符串序列判定】 输入两个字符串S和L，都只包含英文小写字母。S长度 public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()) { String s1 = sc.nextLine(); String s2 = sc.nextLine(); sp20(s1, s2); } sc.close(); } public static void sp20(String s1, String s2) { int nowIndex = 0; for (int i = 0; i 020、【游戏规则】 游戏规则：输入一个只包含英文字母的字符串，字符串中的两个字母如果相邻且相同，就可以消除。 在字符串上反复执行消除的动作，直到无法继续消除为止，此时游戏结束。 输出最终得到的字符串长度。 输入描述： 输出描述： 备注： 示例1： 输入:gg 输出:0 public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()) { String s = sc.next(); sp21(s); } sc.close(); } public static void sp21(String s) { Pattern p = Pattern.compile(\"(.)\\\\1\"); while (true) { boolean flag = false; Matcher m = p.matcher(s); while (m.find()) { flag = true; String g = m.group(); System.out.println(g); s = s.replace(g, \"\"); } if (!flag) break; } System.out.println(s.length()); } 021、【矩形相交的面积】---未完成 在坐标系中，给定3个矩形，求相交区域的面积。 022、【单词接龙】 单词接龙的规则是：可用于接龙的单词首字母必须要前一个单词的尾字母相同；当存在多个首字母相同的单词时，取长度最长的单词，如果长度也相 等，则取字典序最小的单词；已经参与接龙的单词不能重复使用。 输入描述： 输出描述： 备注： 示例1： 输入 0 6 word dd da dc dword d 输出 worddwordda public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()) { int index = sc.nextInt(); int n = sc.nextInt(); ArrayList list = new ArrayList(); for (int i = 0; i list, int index) { StringBuffer sb = new StringBuffer(list.get(index)); list.remove(index); while (true) { boolean flag = false; int i = 0; String temp = \"\"; int del = 0; while (i temp.length()) { temp = list.get(i); del = i; } else if (list.get(i).length() == temp.length()) { if (temp.compareTo(list.get(i)) > 0) temp = list.get(i); del = i; } } i++; } if (!flag) break; sb.append(temp); list.remove(del); } System.out.println(sb); } 023、【日志排序】 运维工程师采集到某产品现网运行一天产生的日志N条，现需根据日志时间按时间先后顺序对日志进行排序。 日志时间格式为： H:M:S.N H表示小时(0-23)，M表示分钟(0-59)，S表示秒(0-59)，N表示毫秒(0-999) 时间可能并没有补齐，也就是说: 01:01:01.001，也可能表示为1:1:1.1 输入描述： 第一行输入一个整数N，表示日志条数，1 public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()) { int n = sc.nextInt(); String[] arr = new String[n]; for (int i = 0; i list = new ArrayList<>(); for (long l : arr0) { if (!list.contains(l)) list.add(l); } Collections.sort(list); for (Long aLong : list) { for (int i = 0; i 024、【猴子爬山】 一天一只顽猴想去从山脚爬到山顶，途中经过一个有个N个台阶的阶梯，但是这猴子有一个习惯： 每一次只能跳1步或跳3步，试问猴子通过这个阶梯 输入描述： 输入只有一个整数N（0 public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()) { int n = sc.nextInt(); System.out.println(sp25(n)); } sc.close(); } private static int sp25(int n) { if (n == 1 || n == 2) return 1; if (n == 3) return 2; return sp25(n - 1) + sp25(n - 3); } 025、【字符统计及重排】 给出一个仅包含字母的字符串，不包含空格，统计字符串中各个字母（区分大小写）出现的次数，并按照字母出现次数从大到小的顺序输出各个 字母及其出现次数。如果次数相同，按照自然顺序进行排序，且小写字母在大写字母之前。 输入描述： 输入一行，为一个仅包含字母的字符串。 输出描述： 按照字母出现次数从大到小的顺序输出各个字母和字母次数，用英文分号分隔，注意末尾的分号；字母和次数间用英文冒号分隔。 示例1： 输入 xyxyXX 输出 x:2;y:2;X:2; public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()) { String s = sc.next(); sp26(s); } sc.close(); } private static void sp26(String s) { LinkedHashMap map = new LinkedHashMap<>(); for (int i = 0; i > entries = map.entrySet(); ArrayList list = new ArrayList<>(); for (Map.Entry entry : entries) { if (!list.contains(entry.getValue())) list.add(entry.getValue()); } Collections.sort(list); for (int i = list.size() - 1; i >= 0; i--) { for (Map.Entry entry : entries) { if (list.get(i) == entry.getValue()) System.out.print(entry.getKey() + \":\" + list.get(i) + \";\"); } } } 026、【数字序列】 输入描述： 输入一个字符串仅包含大小写字母和数字，输入的字符串最大不超过255个字符。 输出描述： 最长的非严格递增连续数字序列的长度 示例1： 输入 abc2234019A334bc 输出 4 public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()) { String s = sc.next(); sp27(s); } sc.close(); } private static void sp27(String s) { Pattern p = Pattern.compile(\"\\\\d+\"); Matcher m = p.matcher(s); int maxLen = 0; while (m.find()) { String s1 = m.group(); int nowMax = s1.charAt(0); int nowLen = 1; for (int i = 1; i maxLen) maxLen = nowLen; } } System.out.println(maxLen); } 027、【字符串分割】 给定一个非空字符串S，其被N个‘-’分隔成N+1的子串，给定正整数K，要求除第一个子串外，其余的子串每K个字符组成新的子串，并用‘-’分 隔。对于新组成的每一个子串，如果它含有的小写字母比大写字母多，则将这个子串的所有大写字母转换为小写字母；反之，如果它含有的大写字母比小写字母多， 则将这个子串的所有小写字母转换为大写字母；大小写字母的数量相等时，不做转换。 输入描述： 输入为两行，第一行为参数K，第二行为字符串S。 输出描述： 输出转换后的字符串。 示例1： 输入 3 12abc-abCABc-4aB@ 输出 12abc-abc-ABC-4aB-@ public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()) { int n = sc.nextInt(); String s = sc.next(); sp28(n, s); } sc.close(); } public static void sp28(int n, String s) { String[] arr = s.split(\"-\"); ArrayList list = new ArrayList<>(); list.add(arr[0]); for (int i = 1; i 2) { list.add(sb.substring(0, 3)); sb = sb.substring(3); } if (sb.length() % 3 != 0) list.add(sb); } System.out.print(list.get(0)); for (int i = 1; i low) System.out.print(\"-\" + list.get(i).toUpperCase()); else if (up 028、【寻找相同子串】 给你两个字符串 t 和 p ，要求从 t 中找到一个和 p 相同的连续子串，并输出该字串第一个字符的下标。 输入描述： 输入文件包括两行，分别表示字符串 t 和 p ，保证 t 的长度不小于 p ，且 t 的长度不超过1000000，p 的长度不超过10000。 输出描述： 如果能从 t 中找到一个和 p 相等的连续子串，则输出该子串第一个字符在t中的下标（下标从左到右依次为1,2,3,…）；如果不能则输出”No”；如果含有多个这样 的子串，则输出第一个字符下标最小的。 示例1： 输入 AVERDXIVYERDIAN RDXI 输出 4 public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()) { String s1 = sc.nextLine(); String s2 = sc.nextLine(); sp29(s1, s2); } sc.close(); } private static void sp29(String s1, String s2) { for (int a = 0, b = a + s2.length(); b 029、【数组去重和排序】 给定一个乱序的数组，删除所有的重复元素，使得每个元素只出现一次，并且按照出现的次数从高到低进行排序，相同出现次数按照第一次出现顺序进行先后排序。 输入描述： 一个数组 输出描述： 去重排序后的数组 备注： 示例1： 输入 1,3,3,3,2,4,4,4,5 输出 3,4,1,2,5 public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()) { String[] arr = sc.nextLine().split(\",\"); sp30(arr); } sc.close(); } private static void sp30(String[] arr) { LinkedHashMap map = new LinkedHashMap<>(); for (String s : arr) { if (!map.containsKey(s)) map.put(s, 1); else map.put(s, map.get(s) + 1); } ArrayList list = new ArrayList<>(); for (Integer value : map.values()) { if (!list.contains(value)) list.add(value); } Collections.sort(list); for (int i = list.size() - 1; i >= 0; i--) { int len = 0; for (String s : map.keySet()) { if (len == map.size() - 1 && map.get(s) == list.get(i)) { System.out.print(s); } else if (map.get(s) == list.get(i)) { System.out.print(s + \",\"); } len++; } } } 030、【根据某条件聚类最少交换次数】 给出数字K,请输出所有结果小于K的整数组合到一起的最少交换次数。 组合一起是指满足条件的数字相邻，不要求相邻后在数组中的位置。 数据范围 -100 public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()) { int m = sc.nextInt(); int[] arr = new int[m]; for (int i = 0; i list = new ArrayList<>(); for (int s : arr) { if (!list.contains(s)) list.add(s); } Collections.sort(list); if (2 * n > list.size()) { System.out.println(-1); return; } int sum = 0; for (int i = 0; i 031、【最大花费金额】 双十一众多商品进行打折销售，小明想购买自己心仪的一些物品，但由于受购买资金限制，所以他决定从众多心仪商品中购买三件，而且想尽可能 的花完资金，现在请你设计一个程序帮助小明计算尽可能花费的最大资金数额。 输入描述： 输入第一行为一维整型数组M，数组长度小于100，数组元素记录单个商品的价格，单个商品价格小于1000。 输入第二行为购买资金的额度R，R小于100000。 输出描述： 备注： 示例1： 输入 23,26,36,27 78 输出 76 public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()) { String s = sc.nextLine(); int limit = sc.nextInt(); sp37(s, limit); } sc.close(); } private static void sp37(String s, int limit) { String[] temp = s.split(\",\"); int[] arr = new int[temp.length]; for (int i = 0; i list = new ArrayList<>(); for (int i = 0; i 032、【最大括号深度】 现有一字符串仅由 '('，')'，'{'，'}'，'['，']'六种括号组成。 若字符串满足以下条件之一，则为无效字符串： ①任一类型的左右括号数量不相等； ②存在未按正确顺序（先左后右）闭合的括号。 输出括号的最大嵌套深度，若字符串无效则输出0。 0≤字符串长度≤100000 输入描述： 输出描述： 示例1： 输入 输出 public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()) { String s = sc.nextLine(); System.out.println(sp38(s)); } sc.close(); } private static int sp38(String s) { int len = s.length(); if (len % 2 != 0) { return 0; } else { int maxLen = 0, nowLen = 0; for (int i = 0; i maxLen) maxLen = nowLen; } return maxLen; } } 033、【数组拼接】---未完成 现在有多组整数数组，需要将它们合并成一个新的数组。合并规则，从每个数组里按顺序取出固定长度的内容合并到新的数组中，取完的内容会删除掉，如果该行不 足固定长度或者已经为空，则直接取出剩余部分的内容放到新的数组中，继续下一行。 输入描述： 第一行是每次读取的固定长度，0 public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()) { int l = sc.nextInt(); int n = sc.nextInt(); LinkedHashMap map = new LinkedHashMap<>(); for (int i = 0; i map) { Set> entries = map.entrySet(); ArrayList list = new ArrayList<>(); boolean flag = true; while (flag) { for (Map.Entry entry : entries) { List value = entry.getValue(); int len = value.size(); if (len >= l) { for (int i = 0; i 0 && len 034、【字符串统计】 给定两个字符集合，一个为全量字符集，一个为已占用字符集。已占用的字符集中的字符不能再使用，要求输出剩余可用字符集。 输入描述： 1、输入为一个字符串，一定包含@符号。@前的为全量字符集，@后的字为已占用字符集。 2、已占用字符集中的字符一定是全量字符集中的字符。字符集中的字符跟字符之间使用英文逗号分隔。 3、每个字符都表示为字符加数字的形式，用英文冒号分隔，比如a:1，表示1个a字符。 4、字符只考虑英文字母，区分大小写，数字只考虑正整形，数量不超过100。 5、如果一个字符都没被占用，@标识仍然存在，例如a:3,b:5,c:2@ 输出描述： 输出可用字符集，不同的输出字符集之间回车换行。 注意，输出的字符顺序要跟输入一致。不能输出b:3,a:2,c:2 如果某个字符已全被占用，不需要再输出。 示例1： 输入 a:3,b:5,c:2@a:1,b:2 输出 a:2,b:3,c:2 public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()) { String s = sc.nextLine(); sp40(s); } sc.close(); } private static void sp40(String s) { String[] arr = s.split(\"@\"); String[] arr1 = arr[0].split(\",\"); String[] arr2 = arr[1].split(\",\"); LinkedHashMap mapAll = new LinkedHashMap<>(); LinkedHashMap mapUsed = new LinkedHashMap<>(); for (int i = 0; i 0) sb.append(s1 + \":\" + mapAll.get(s1) + \",\"); } System.out.println(sb.substring(0, sb.length() - 1)); } 035、3TLV解码 TLV编码是按[Tag Length Value]格式进行编码的，一段码流中的信元用Tag标识，Tag在码 流中唯一不重复，Length表示信元Value的长度，Value表示信元的值。 码流以某信元的Tag开头，Tag固定占一个字节，Length固定占两个字节，字节序为小端序。 现给定TLV格式编码的码流，以及需要解码的信元Tag，请输出该信元的Value。 输入码流的16机制字符中，不包括小写字母，且要求输出的16进制字符串中也不要包含小写字母； 码流字符串的最大长度不超过50000个字节。 输入描述: 输入的第一行为一个字符串，表示待解码信元的Tag； 输入的第二行为一个字符串，表示待解码的16进制码流，字节之间用空格分隔。 输出描述: 输出一个字符串，表示待解码信元以16进制表示的Value。 示例1： 输入 31 32 01 00 AE 90 02 00 01 02 30 03 00 AB 32 31 31 02 00 32 33 33 01 00 CC 输出 32 33 说明 需要解析的信元的Tag是31，从码流的起始处开始匹配，Tag为32的信元长度为1（01 00，小端 序表示为1）；第二个信元的Tag是90，其长度为2；第三个信元的Tag是30，其长度为3；第四个信元的 Tag是31，其长度为2（02 00），所以返回长度后面的两个字节即可，即32 33。 import java.util.ArrayList; import java.util.HashMap; import java.util.Scanner; public class Spd03 { public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()) { String tag = sc.nextLine(); String s = sc.nextLine(); spd03(tag, s); } sc.close(); } private static void spd03(String tag, String s) { String[] arr = s.split(\" \"); HashMap> map = new HashMap<>(); for (int i = 0; i list = new ArrayList<>(); for (int j = i + 1; j list = map.get(s1); for (String s2 : list) { sb.append(s2 + \" \"); } } } System.out.println(sb.toString().trim()); } } 036、【分班】 园两个班的小朋友在排队时混在了一起，每位小朋友都知道自己是否与前面一位小朋友是否同班，请你帮忙把同班的小朋友找出来。 小朋友的编号为整数，与前一位小朋友同班用Y表示，不同班用N表示。 输入描述： 输入为空格分开的小朋友编号和是否同班标志。 比如：6/N 2/Y 3/N 4/Y，表示共4位小朋友，2和6同班，3和2不同班，4和3同班。 其中，小朋友总数不超过999，每个小朋友编号大于0，小于等于999。 不考虑输入格式错误问题。 输出描述： 输出为两行，每一行记录一个班小朋友的编号，编号用空格分开。且： 1、编号需要按照大小升序排列，分班记录中第一个编号小的排在第一行。 2、若只有一个班的小朋友，第二行为空行。 3、若输入不符合要求，则直接输出字符串ERROR。 示例1： 输入 1/N 2/Y 3/N 4/Y 输出 1 2 3 4 public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()) { String s = sc.nextLine(); sp42(s); } sc.close(); } private static void sp42(String s) { String[] s1 = s.split(\" \"); ArrayList list1 = new ArrayList<>(); ArrayList list2 = new ArrayList<>(); ArrayList temp = list1; for (int i = 0; i 037、 【勾股数元组】 如果3个正整数(a,b,c)满足a + b = c 的关系，则称(a,b,c)为勾股数（著名的勾三股四弦五），为了探索勾股数的规律，我们定义如果勾股数(a,b,c) 之间两两互质（即a与b，a与c，b与c之间均互质，没有公约数），则其为勾股数元祖（例如(3,4,5)是勾股数元祖，(6,8,10)则不是勾股数元祖）。请求出给定范围 [N,M]内，所有的勾股数元祖。 输入描述： 起始范围N，1 a,b,c请保证a 多组勾股数元祖请按照a升序，b升序，最后c升序的方式排序输出； 给定范围中如果找不到勾股数元祖时，输出”NA”。 示例1： 输入 1 20 输出 3 4 5 5 12 13 8 15 17 public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()) { int n = sc.nextInt(); int m = sc.nextInt(); sp43(n, m); } sc.close(); } private static void sp43(int n, int m) { ArrayList list = new ArrayList<>(); for (int i = n; i 038、【用户调度问题】 在通信系统中，一个常见的问题是对用户进行不同策略的调度，会得到不同的系统消耗和性能。 假设当前有n个待串行调度用户，每个用户可以使用A/B/C三种不同的调度策略，不同的策略会消耗不同的系统资源。请你根据如下规则进行用户调度，并返回总的 消耗资源数。 规则： 相邻的用户不能使用相同的调度策略，例如，第1个用户使用了A策略，则第2个用户只能使用B或者C策略。 对单个用户而言，不同的调度策略对系统资源的消耗可以归一化后抽象为数值。例如，某用户分别使用A/B/C策略的系统消耗分别为15/8/17。 每个用户依次选择当前所能选择的对系统资源消耗最少的策略（局部最优），如果有多个满足要求的策略，选最后一个。 输入描述： 第一行表示用户个数n 接下来每一行表示一个用户分别使用三个策略的系统消耗resA resB resC 输出描述： 最优策略组合下的总的系统资源消耗数 备注： 示例1： 输入 3 15 8 17 12 20 9 11 7 5 输出 24 public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()) { int n = sc.nextInt(); int[][] dp = new int[n + 1][3]; for (int i = 0; i 039、【组成最大数】 小组中每位都有一张卡片，卡片上是6位内的正整数，将卡片连起来可以组成多种数字，计算组成的最大数字。 输入描述： “,”号分割的多个正整数字符串，不需要考虑非数字异常情况，小组最多25个人 输出描述： 最大的数字字符串 示例1： 输入 22,221 输出 22221 public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()) { String s = sc.nextLine(); sp45(s); } sc.close(); } private static void sp45(String s) { String[] arr = s.split(\",\"); String[] rec = new String[arr.length]; rec[0] = arr[0]; for (int i = 1; i = Integer.parseInt(arr[i] + rec[i - 1])) rec[i] = rec[i - 1] + arr[i]; else rec[i] = arr[i] + rec[i - 1]; } System.out.println(rec[rec.length - 1]); } ​ 040、【火星文计算】 已知火星人使用的运算符为#、$，其与地球人的等价公式如下： x#y = 2*x+3*y+4 x$y = 3*x+y+2 1、其中x、y是无符号整数 2、地球人公式按C语言规则计算 3、火星人公式中，$的优先级高于#，相同的运算符，按从左到右的顺序计算 现有一段火星人的字符串报文，请你来翻译并计算结果。 输入描述： 火星人字符串表达式（结尾不带回车换行） 输入的字符串说明： 字符串为仅由无符号整数和操作符（#、$）组成的计算表达式。例如：123#4$5#67$78。 1、用例保证字符串中，操作数与操作符之间没有任何分隔符。 2、用例保证操作数取值范围为32位无符号整数。 3、保证输入以及计算结果不会出现整型溢出。 4、保证输入的字符串为合法的求值报文，例如：123#4$5#67$78 5、保证不会出现非法的求值报文，例如类似这样字符串： #4$5 //缺少操作数 4$5# //缺少操作数 4#$5 //缺少操作数 4 $5 //有空格 3+4-5*6/7 //有其它操作符 12345678987654321$54321 //32位整数计算溢出 输出描述： 根据输入的火星人字符串输出计算结果（结尾不带回车换行） 示例1： 输入 7#6$5#12 输出 226 public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()) { String s = sc.next(); sp46(s); } sc.close(); } private static void sp46(String s) { String[] arr = s.split(\"#\"); for (int i = 0; i 041、【第k个排列】 给定参数n，从1到n会有n个整数：1,2,3,…,n，这n个数字共有 n! 种排列。 按大小顺序升序列出所有排列情况，并一一标记，当 n = 3 时, 所有排列如下： \"123\" \"132\" \"213\" \"231\" \"312\" \"321\" 给定 n 和 k，返回第 k 个排列。 输入描述： 输入两行，第一行为n，第二行为k，给定 n 的范围是 [1,9]，给定 k 的范围是[1,n!]。 输出描述： 输出排在第k位置的数字。 示例1： 输入 3 3 输出 213 public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()) { int n = sc.nextInt(); int index = sc.nextInt(); sp47(n, index); } sc.close(); } public static void sp47(int n, int index) { StringBuffer min = new StringBuffer(); StringBuffer max = new StringBuffer(); for (int j = 1; j 042、 【数字反转打印】 小华是个很有对数字很敏感的小朋友，他觉得数字的不同排列方式有特殊美感。某天，小华突发奇想，如果数字多行排列，第一行1个数，第二行2个，第三行3个， 即第n行有n个数字，并且奇数行正序排列，偶数行逆序排列，数字依次累加。这样排列的数字一定很有意思。聪明的你能编写代码帮助小华完成这个想法吗？ 规则总结如下： a、每个数字占据4个位置，不足四位用‘’补位，如1打印为1**。 b、数字之间相邻4空格。 c、数字的打印顺序按照正序逆序交替打印,奇数行正序，偶数行逆序。 d、最后一行数字顶格，第n-1行相对第n行缩进四个空格 输入描述： 第一行输入为N，表示打印多少行; 1 3XXXX2* 备注： 示例1： 输入 2 输出 1*** 3*** 2*** public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()) { int n = sc.nextInt(); ps48(n); } sc.close(); } public static void ps48(int n) { int sum = 1; for (int i = 0; i = 0; j--) { System.out.print(\"\\t\"); } if (i % 2 == 0) { for (int j = 0; j = 0; j--) { System.out.print(temp[j]); int len = String.valueOf(temp[j]).length(); if (len 043、【路灯照明问题】 在一条笔直的公路上安装了N个路灯，从位置0开始安装，路灯之间间距固定为100米。 每个路灯都有自己的照明半径，请计算第一个路灯和最后一个路灯之间，无法照明的区间的长度和。 输入描述： 第一行为一个数N，表示路灯个数，1 public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()) { int n = sc.nextInt(); int[] arr = new int[n]; for (int i = 0; i 0) sum += temp; } System.out.println(sum); } 044、【数据分类】 对一个数据a进行分类，分类方法为：此数据a（四个字节大小）的四个字节相加对一个给定的值b取模，如果得到的结果小于一个给定的值c，则数据a为有效类型， 其类型为取模的值；如果得到的结果大于或者等于c，则数据a为无效类型。 比如一个数据a=0x01010101，b=3，按照分类方法计算（0x01+0x01+0x01+0x01）%3=1，所以如果c=2，则此a为有效类型，其类型为1，如果c=1，则此a为 无效类型； 又比如一个数据a=0x01010103，b=3，按照分类方法计算（0x01+0x01+0x01+0x03）%3=0，所以如果c=2，则此a为有效类型，其类型为0，如果c=0，则此a 为无效类型。 输入12个数据，第一个数据为c，第二个数据为b，剩余10个数据为需要分类的数据，请找到有效类型中包含数据最多的类型，并输出该类型含有多少个数据。 输入描述： 输入12个数据，用空格分隔，第一个数据为c，第二个数据为b，剩余10个数据为需要分类的数据。 输出描述： 输出最多数据的有效类型有多少个数据。 示例1： 输入 3 4 256 257 258 259 260 261 262 263 264 265 输出 3 public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()) { int c = sc.nextInt(); int b = sc.nextInt(); int[] arr = new int[10]; for (int i = 0; i list = new ArrayList<>(); for (int a = 0, ab = 2; ab bb ? aa : bb) > cc ? (aa > bb ? aa : bb) : cc; System.out.println(temp); } 045、【We Are A Team】 总共有n个人在机房，每个人有一个标号（1 public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()) { int n = sc.nextInt(); int m = sc.nextInt(); if (n 100000) { System.out.println(\"NULL\"); continue; } String[] arr = new String[m]; for (int i = 0; i result = new ArrayList<>(); HashSet set = new HashSet<>(); for (String s : arr) { String[] s1 = s.split(\" \"); int a = Integer.parseInt(s1[0]); int b = Integer.parseInt(s1[1]); int c = Integer.parseInt(s1[2]); if (c == 0 && a >= 1 && a = 1 && b n || b n || c != 1) { result.add(\"da pian zi\"); } else { if (set.contains(a) && set.contains(b)) result.add(\"we are a team\"); else result.add(\"we are not a team\"); } } } for (String s : result) { System.out.println(s); } } 046、【数列描述】 有一个数列a[N] (N=60)，从a[0]开始，每一项都是一个数字。数列中a[n+1]都是a[n]的描述。其中a[0]=1。 规则如下： a[0]:1 a[1]:11(含义：其前一项a[0]=1是1个1，即“11”。表示a[0]从左到右，连续出现了1次“1”） a[2]:21(含义：其前一项a[1]=11，从左到右：是由两个1组成，即“21”。表示a[1]从左到右，连续出现了两次“1”) a[3]:1211(含义：其前一项a[2]=21，从左到右：是由一个2和一个1组成，即“1211”。表示a[2]从左到右，连续出现了1次“2”，然后又连续出现了1次“1”) a[4]:111221(含义：其前一项a[3]=1211，从左到右：是由一个1、一个2、两个1组成，即“111221”。表示a[3]从左到右，连续出现了1次“1”，连续出现了1 次“2”，连续出现了两次“1”) 请输出这个数列的第n项结果（a[n]，0≤n≤59）。 输入描述： 数列的第n项(0≤n≤59)： 4 输出描述： 数列的内容： 111221 示例1： 输入 4 输出 111221 public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()) { int n = sc.nextInt(); sp52(n); } sc.close(); } public static void sp52(int n) { ArrayList list = new ArrayList<>(); list.add(\"1\"); Pattern p = Pattern.compile(\"(.)\\\\1*\"); for (int i = 1; i 047、【查找众数及中位数】 1.众数是指一组数据中出现次数量多的那个数，众数可以是多个 2.中位数是指把一组数据从小到大排列，最中间的那个数，如果这组数据的个数是奇数，那最中间那个就是中位数，如果这组数据的个数为偶数，那就把中间的两个 数之和除以2，所得的结果就是中位数 3.查找整型数组中元素的众数并组成一个新的数组，求新数组的中位数 输入描述： 输入一个一维整型数组，数组大小取值范围 0 public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()) { String s = sc.nextLine(); sp53(s); } sc.close(); } public static void sp53(String s) { String[] arr = s.split(\"\\\\s+\"); HashMap map = new HashMap<>(); for (String s1 : arr) { if (!map.containsKey(s1)) map.put(s1, 1); else map.put(s1, map.get(s1) + 1); } Collection values = map.values(); Integer max = Collections.max(values); ArrayList list = new ArrayList<>(); for (String key : map.keySet()) { if (map.get(key) == max) { for (String s1 : arr) { if (key.equals(s1)) list.add(Integer.parseInt(s1)); } } } Collections.sort(list); int result = 0; if (list.size() % 2 == 0) { result = (list.get(list.size() / 2) + list.get(list.size() / 2 - 1)) / 2; } else { result = list.get((list.size() - 1) / 2); } System.out.println(result); } 048、【连续字母长度】 给定一个字符串，只包含大写字母，求在包含同一字母的子串中，长度第 k 长的子串的长度，相同字母只取最长的那个子串。 输入描述： 第一行有一个子串(1 public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()) { String s = sc.next(); int n = sc.nextInt(); sp55(s, n); } sc.close(); } public static void sp55(String s, int n) { HashMap map = new HashMap<>(); Pattern p = Pattern.compile(\"(.)\\\\1*\"); Matcher m = p.matcher(s); while (m.find()) { String temp = m.group(); if (!map.values().contains(temp.charAt(0))) { int len = temp.length(); if (!map.keySet().contains(len)) map.put(len, temp.charAt(0)); } } Set set = map.keySet(); ArrayList list = new ArrayList<>(set); int result = -1; if (list.size() - n >= 0) result = list.get(list.size() - n); System.out.println(result); } 049、【太阳能板最大面积】 给航天器一侧加装长方形或正方形的太阳能板（图中的红色斜线区域），需要先安装两个支柱（图中的黑色竖条），再在支柱的中间部分固定太阳能板。但航天器不 同位置的支柱长度不同，太阳能板的安装面积受限于最短一侧的那根支柱长度。如图： 现提供一组整形数组的支柱高度数据，假设每根支柱间距离相等为1个单位长度，计算如何选择两根支柱可以使太阳能板的面积最大。 输入描述： 10,9,8,7,6,5,4,3,2,1 注：支柱至少有2根，最多10000根，能支持的高度范围1~10^9的整数。柱子的高度是无序的，例子中递减只是巧合。 输出描述： 可以支持的最大太阳能板面积：（10米高支柱和5米高支柱之间） 25 备注： 10米高支柱和5米高支柱之间宽度为5，高度取小的支柱高也是5，面积为25。任取其他两根支柱所能获得的面积都小于25。所以最大的太阳能板面积为25。 示例1： 输入 10,9,8,7,6,5,4,3,2,1 输出 25 public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()) { String s = sc.next(); sp56(s); } sc.close(); } public static void sp56(String s) { String[] arr = s.split(\",\"); int max = 0; for (int i = 0; i max ? temp : max; } } System.out.println(max); } 050、【报数游戏】 100个人围成一圈，每个人有一个编码，编号从1开始到100。他们从1开始依次报数，报到为M的人自动退出圈圈，然后下一个人接着从1开始报数， 直到剩余的人数小于M。请问最后剩余的人在原先的编号为多少？ 输入描述： 输入一个整数参数M 输出描述： 如果输入参数M小于等于1或者大于等于100，输出“ERROR!”；否则按照原先的编号从小到大的顺序，以英文逗号分割输出编号字符串 示例1： 输入 3 输出 58,91 public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()) { int n = sc.nextInt(); sp57(n); } sc.close(); } public static void sp57(int n) { if (n = 100) { System.out.println(\"ERROR\"); return; } LinkedHashMap map = new LinkedHashMap<>(); for (int i = 1; i 051、【判断一组不等式是否满足约束并输出最大差】 给定一组不等式，判断是否成立并输出不等式的最大差(输出浮点数的整数部分)，要求：1）不等式系数为double类 型，是一个二维数组；2）不等式的变量为int类型，是一维数组；3）不等式的目标值为double类型，是一维数组；4）不等式约束为字符串数组，只能 是：\">\",\">=\",\"x1+a12x2+a13x3+a14x4+a15x5x1+a22x2+a23x3+a24x4+a25x5x1+a32x2+a33x3+a34x4+a35x5x1+a12x2+a13x3+a14x4+a15x5-b1), (a21x1+a22x2+a23x3+a24x4+a25x5-b2), (a31x1+a32x2+a33x3+a34x4+a35x5-b3) }，类型为整数(输出浮点数的整数部分) 输入描述： 输入：a11,a12,a13,a14,a15;a21,a22,a23,a24,a25;a31,a32,a33,a34,a35;x1,x2,x3,x4,x5;b1,b2,b3; public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()) { String s = sc.nextLine(); sp58(s); } sc.close(); } public static void sp58(String s) { String[] arr = s.split(\";\"); boolean flag = true; Double result = Double.MIN_VALUE; String[] x = arr[arr.length - 3].split(\",\"); String[] b = arr[arr.length - 2].split(\",\"); String[] comp = arr[arr.length - 1].split(\",\"); for (int i = 0; i \")) { if (!(sum > Double.parseDouble(b[i]))) flag = false; } else if (comp[i].equals(\">=\")) { if (!(sum >= Double.parseDouble(b[i]))) flag = false; } else if (comp[i].equals(\" result) result = tep; } System.out.print(flag + \",\" + (int) Math.floor(result)); } 052、【分糖果】 小明从糖果盒中随意抓一把糖果，每次小明会取出一半的糖果分给同学们。 当糖果不能平均分配时，小明可以选择从糖果盒中（假设盒中糖果足够）取出一个糖果或放回一个糖果。 小明最少需要多少次（取出、放回和平均分配均记一次），能将手中糖果分至只剩一颗。 输入描述： 抓取的糖果数（ public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()) { int n = sc.nextInt(); sp59(n); } sc.close(); } public static void sp59(int n) { int times = 0; while (true) { if (n == 1) { break; } if (n % 2 != 0) { int temp = n / 2; if (temp / 2 == 0) { n -= 1; } else { n += 1; } times++; } n /= 2; times++; } System.out.println(times); } 053、【计算面积】 绘图机器的绘图笔初始位置在原点（0, 0），机器启动后其绘图笔按下面规则绘制直线： 1）尝试沿着横向坐标轴正向绘制直线，直到给定的终点值E。 2）期间可通过指令在纵坐标轴方向进行偏移，并同时绘制直线，偏移后按规则1 绘制直线；指令的格式为X offsetY，表示在横坐标X 沿纵坐标方向偏移，offsetY为 正数表示正向偏移，为负数表示负向偏移。 给定了横坐标终点值E、以及若干条绘制指令，请计算绘制的直线和横坐标轴、以及 X=E 的直线组成图形的面积。 输入描述： 首行为两个整数 N E，表示有N条指令，机器运行的横坐标终点值E。 接下来N行，每行两个整数表示一条绘制指令X offsetY，用例保证横坐标X以递增排序方式出现，且不会出现相同横坐标X。 取值范围：0 public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()) { int n = sc.nextInt(); int x_max = sc.nextInt(); LinkedHashMap map = new LinkedHashMap<>(); for (int i = 0; i map) { int sum = 0, lastKey = 0, lastValue = 0; for (Map.Entry entry : map.entrySet()) { int key = entry.getKey(); int value = entry.getValue(); sum += ((key - lastKey) * Math.abs(lastValue)); lastKey = key; lastValue = value + lastValue; } System.out.println(sum); } 054、【求解连续数列】 已知连续正整数数列{K}=K1,K2,K3...Ki的各个数相加之和为S，i=N (0 public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()) { int sum = sc.nextInt(); int n = sc.nextInt(); sp61(sum, n); } sc.close(); } public static void sp61(int sum, int n) { int first = (sum * 2 / n - n + 1) / 2; int real = 0; for (int i = 0; i 055、【判断字符串子序列】 给定字符串 target和 source, 判断 target 是否为 source 的子序列。 你可以认为 target 和 source 中仅包含英文小写字母。字符串 source可能会很长（长度 ~= 500,000），而 target 是个短字符串（长度 public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()) { String target = sc.next(); String source = sc.next(); sp62(target, source); } sc.close(); } private static void sp62(String target, String source) { char[] ch_target = target.toCharArray(); char[] ch_source = source.toCharArray(); int index = ch_source.length - 1; for (int i = ch_target.length - 1; i >= 0; i--) { char c = ch_target[i]; for (int j = index; j >= 0; j--) { char c1 = ch_source[j]; if (c == c1) { index = j; break; } else if (j == 0) { index = -1; return; } } } System.out.println(index); } 056、【最长的顺子】 斗地主起源于湖北十堰房县，据传是一位叫吴修全的年轻人根据当地流行的扑克玩法“跑得快”改编的，如今已风靡整个中国，并流行于互联网上。 牌型: 单顺, 又称顺子，最少5张牌，最多12张牌（3⋯A），不能有2，也不能有大小王，不计花色 例如：3-4-5-6-7-8，7-8-9-10-J-Q，3-4-5-6-7-8-9-10-J-Q-K-A 可用的牌 3 public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()) { String s1 = sc.nextLine(); String s2 = sc.nextLine(); sp63(s1, s2); } sc.close(); } private static void sp63(String s1, String s2) { String[] arr1 = s1.split(\"-\"); String[] arr2 = s2.split(\"-\"); HashMap map = new HashMap<>(); for (String s : arr1) { if (s.equals(\"J\")) { s = \"11\"; } else if (s.equals(\"Q\")) { s = \"12\"; } else if (s.equals(\"K\")) { s = \"13\"; } else if (s.equals(\"A\")) { s = \"14\"; } if (!map.containsKey(s)) map.put(s, 1); else map.put(s, map.get(s) + 1); } for (String s : arr2) { if (s.equals(\"J\")) { s = \"11\"; } else if (s.equals(\"Q\")) { s = \"12\"; } else if (s.equals(\"K\")) { s = \"13\"; } else if (s.equals(\"A\")) { s = \"14\"; } if (!map.containsKey(s)) map.put(s, 1); else map.put(s, map.get(s) + 1); } int lastOne = 0, maxLen = 0, nowLen = 0; for (int i = 3; i maxLen) { maxLen = nowLen; lastOne = i; } } StringBuffer sb = new StringBuffer(); if (maxLen >= 5) { for (int i = lastOne - maxLen + 1; i 057、【检查是否存在满足条件的数字组合】 给定一个正整数数组，检查数组中是否存在满足规则的数字组合 规则： A = B + 2C 输入描述： 第一行输出数组的元素个数。 接下来一行输出所有数组元素，用空格隔开 输出描述： 如果存在满足要求的数，在同一行里依次输出规则里A/B/C的取值，用空格隔开。 如果不存在，输出0。 备注： 数组长度在3-100之间。 数组成员为0-65535，数组成员可以重复，但每个成员只能在结果算式中使用一次。如：数组成员为[0, 0, 1, 5]，0出现2次是允许的，但结果0 = 0 + 2 * 0是不 允许的，因为算式中使用了3个0。 用例保证每组数字里最多只有一组符合要求的解。 示例1： 输入 4 2 7 3 0 输出 7 3 2 public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()) { int n = sc.nextInt(); int[] arr = new int[n]; for (int i = 0; i 058、【关联子串】---需要优化 给定两个字符串str1和str2，如果字符串str1中的字符，经过排列组合后的字符串中，只要有一个字符串是str2的子串，则认为str1是str2的关联子串。 若str1是str2的关联子串，请返回子串在str2的起始位置； 若不是关联子串，则返回-1。 示例1： 输入：str1=\"abc\",str2=\"efghicabiii\" 输出：5 解释：str2包含str1的一种排列组合（\"cab\")，此组合在str2的字符串起始位置为5（从0开始计数） 示例2：str1=\"abc\",str2=\"efghicaibii\" 输出：-1。 预制条件： 输入的字符串只包含小写字母； 两个字符串的长度范围[1, 100,000]之间 若str2中有多个str1的组合子串，请返回第一个子串的起始位置。 输入描述： 输入两个字符串，分别为题目中描述的str1、str2。 输出描述： 如果str1是str2的关联子串，则返回子串在str2中的起始位置。 如果str1不是str2的关联子串，则返回-1。 若str2中有多个str1的组合子串，请返回最小的起始位置。 备注： 示例1： 输入 abc efghicabiii 输出 5 public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()) { String str1 = sc.next(); String str2 = sc.next(); sp65(str1, str2); } sc.close(); } private static void sp65(String str1, String str2) { StringBuffer min = new StringBuffer(); StringBuffer max = new StringBuffer(); HashMap map = new HashMap<>(); for (int i = 1; i list = new ArrayList<>(); for (int i = Integer.parseInt(min.toString()); i 0) { System.out.println(Collections.min(list)); } else { System.out.println(-1); } } 059、【用连续自然数之和来表达整数】 一个整数可以由连续的自然数之和来表示。给定一个整数，计算该整数有几种连续自然数之和的表达式，且打印出每种表达式。 输入描述： 一个目标整数T (1 public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()) { int n = sc.nextInt(); sp66(n); } sc.close(); } private static void sp66(int n) { int count = 0; for (int i = 1; i 0) { int temp = first; int tempSum = 0; for (int j = 1; j 060、【流水线】 一个工厂有m条流水线，来并行完成n个独立的作业，该工厂设置了一个调度系统，在安排作业时，总是优先执行处理时间最短的作业。 现给定流水线个数m，需要完成的作业数n, 每个作业的处理时间分别为t1,t2…tn。请你编程计算处理完所有作业的耗时为多少？ 当n>m时，首先处理时间短的m个作业进入流水线，其他的等待，当某个作业完成时，依次从剩余作业中取处理时间最短的进入处理。 输入描述： 第一行为2个整数（采用空格分隔），分别表示流水线个数m和作业数n； 第二行输入n个整数（采用空格分隔），表示每个作业的处理时长t1,t2…tn。 0 public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()) { int m = sc.nextInt(); int n = sc.nextInt(); int[] arr = new int[n]; for (int i = 0; i 061、【执行时长】 为了充分发挥GPU算力，需要尽可能多的将任务交给GPU执行，现在有一个任务数组，数组元素表示在这1秒内新增的任务个数且每秒都有新增任务， 假设GPU最多一次执行n个任务，一次执行耗时1秒，在保证GPU不空闲情况下，最少需要多长时间执行完成 输入描述： 第一个参数为GPU一次最多执行的任务个数，取值范围[1, 10000] 第二个参数为任务数组长度，取值范围[1, 10000] 第三个参数为任务数组，数字范围[1, 10000] 输出描述： 执行完所有任务最少需要多少秒 示例1： 输入 3 5 1 2 3 4 5 输出 6 public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()) { int n = sc.nextInt(); int m = sc.nextInt(); int[] arr = new int[m]; for (int i = 0; i n) { arr[i + 1] += arr[i] - n; } times++; } int temp = arr[arr.length - 1] / n; if (arr[arr.length - 1] % n != 0) temp++; times += temp; System.out.println(times); } 062、【高矮个子排队】---未完成 现在有一队小朋友，他们高矮不同，我们以正整数数组表示这一队小朋友的身高，如数组{5,3,1,2,3}。 我们现在希望小朋友排队，以“高”“矮”“高”“矮”顺序排列，每一个“高”位置的小朋友要比相邻的位置高或者相等；每一个“矮”位置的小朋友要比相邻的 位置矮或者相等； 要求小朋友们移动的距离和最小，第一个从“高”位开始排，输出最小移动距离即可。 例如，在示范小队{5,3,1,2,3}中，{5, 1, 3, 2, 3}是排序结果。{5, 2, 3, 1, 3} 虽然也满足“高”“矮”“高”“矮”顺序排列，但小朋友们的移动距离大，所以不是最 优结果。 移动距离的定义如下所示： 第二位小朋友移到第三位小朋友后面，移动距离为1，若移动到第四位小朋友后面，移动距离为2； 输入描述： 排序前的小朋友，以英文空格的正整数： 4 3 5 7 8 注：小朋友 public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()) { String[] s = sc.nextLine().split(\"\\\\s+\"); int[] arr = new int[s.length]; for (int i = 0; i arr[i+1]){ } }else { } } } 063、【按单词下标区间翻转文章内容】 给定一段英文文章片段，由若干单词组成，单词间以空格间隔，单词下标从0开始。 请翻转片段中指定区间的单词顺序并返回翻转后的内容。 例如给定的英文文章片段为\"I am a developer\"，翻转区间为[0,3]，则输出\"developer a am I\"。 输入描述： 使用换行隔开三个参数，第一个参数为英文文章内容即英文字符串，第二个参数为待翻转内容起始单词下标，第三个参数为待翻转内容最后一个单词下标。 输出描述： 翻转后的英文文章片段所有单词之间以一个半角空格分隔进行输出 备注： 英文文章内容首尾无空格 示例1： 输入 I am a developer 1 2 输出 I a am developer public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()){ String[] arr = sc.nextLine().split(\"\\\\s+\"); int first = Integer.parseInt(sc.nextLine()); int last = Integer.parseInt(sc.nextLine()); sp70(arr, first, last); } sc.close(); } private static void sp70(String[] arr, int first, int last) { for (int a = first,b = last; a 064、【找车位】 停车场有一横排车位，0代表没有停车，1代表有车。至少停了一辆车在车位上，也至少有一个空位没有停车。 为了防剐蹭，需为停车人找到一个车位，使得距停车人的车最近的车辆的距离是最大的，返回此时的最大距离。 输入描述： 1、一个用半角逗号分割的停车标识字符串，停车标识为0或1，0为空位，1为已停车。 2、停车位最多100个。 输出描述： 输出一个整数记录最大距离。 示例1： 输入 1,0,0,0,0,1,0,0,1,0,1 输出 2 public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()) { String[] arr = sc.nextLine().split(\",\"); sp71(arr); } sc.close(); } private static void sp71(String[] arr) { int count = 0, nowCount = 0; for (int i = 0; i count) count = nowCount; nowCount = 0; } } System.out.println(count / 2); } 065、【字符串分割】---未完成 给定非空字符串s，将该字符串分割成一些子串，使每个子串的ASCII码值的和均为水仙花数。 1、若分割不成功，则返回0 2、若分割成功且分割结果不唯一，则返回-1 3、若分割成功且分割结果唯一，则返回分割后子串的数目 输入描述： 1、输入字符串的最大长度为200 输出描述： 根据题目描述中情况，返回相应的结果 备注： “水仙花数”是指一个三位数，每位上数字的立方和等于该数字本身，如371是“水仙花数”，因为：371 = 3^3 + 7^3 + 1^3 示例1： 输入 abc 输出 0 066、【高效的任务规划】---未完成 你有n台机器编号为1~n，每台都需要完成完成一项工作，机器经过配置后都能完成独立完成一项工作。假设第i台机器你需要花B 分钟进行设置，然后开始运 行，J 分钟后完成任务。现在，你需要选择布置工作的顺序，使得用最短的时间完成所有工作。注意，不能同时对两台进行配置，但配置完成的机器们可以同时执行 他们各自的工作。 输入描述： 第一行输入代表总共有M组任务数据（1 067、【工号不够用了怎么办？】---未完成 3020年，空间通信集团的员工人数突破20亿人，即将遇到现有工号不够用的窘境。 现在，请你负责调研新工号系统。继承历史传统，新的工号系统由小写英文字母（a-z）和数字（0-9）两部分构成。新工号由一段英文字母开头，之后跟随一段数 字，比如\"aaahw0001\",\"a12345\",\"abcd1\",\"a00\"。注意新工号不能全为字母或者数字,允许数字部分有前导0或者全为0。 但是过长的工号会增加同事们的记忆成本，现在给出新工号至少需要分配的人数X和新工号中字母的长度Y，求新工号中数字的最短长度Z。 输入描述： 一行两个非负整数 X Y，用数字用单个空格分隔。 0 068、键键盘的输出 有一个特殊的5键键盘，上面有a，ctrl-c，ctrl-x，ctrl-v，ctrl-a五个键。a键在屏幕上输出一个字母a；ctrl-c将当前选择的字母复制到剪贴板；ctrl-x将当前选择的字母复制到剪贴板，并清空选择的字母；ctrl-v将当前剪贴板里的字母输出到屏幕；ctrl-a选择当前屏幕上的所有字母。注意： 1剪贴板初始为空，新的内容被复制到剪贴板时会覆盖原来的内容 2当屏幕上没有字母时，ctrl-a无效 3当没有选择字母时，ctrl-c和ctrl-x无效 4当有字母被选择时，a和ctrl-v这两个有输出功能的键会先清空选择的字母，再进行输出 给定一系列键盘输入，输出最终屏幕上字母的数量。 输入描述: 输入为一行，为简化解析，用数字1 2 3 4 5代表a，ctrl-c，ctrl-x，ctrl-v，ctrl-a五个键的输入，数字用空格分隔 输出描述: 输出一个数字，为最终屏幕上字母的数量 示例1： 输入 1 1 1 输出 3 说明 连续键入3个a，故屏幕上字母的长度为3 示例2： 输入 1 1 5 1 5 2 4 4 输出 2 说明 输入两个a后ctrl-a选择这两个a，再输入a时选择的两个a先被清空，所以此时屏幕只有一个a，后续的ctrl-a，ctrl-c选择并复制了这一个a，最后两个ctrl-v在屏幕上输出两个a，故屏幕上字母的长度为2（第一个ctrl-v清空了屏幕上的那个a） import java.util.Scanner; public class Spd01 { public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()) { String s = sc.nextLine(); spd(s); } sc.close(); } public static void spd(String s) { char[] arr = s.toCharArray(); int sum = 0; int copy = 0; int select = 0; for (char s1 : arr) { if ('1' == s1) { if (select > 0) sum = 1; else sum++; } if ('2' == s1) { copy = select; } if ('3' == s1) { copy = select; select = 0; } if ('4' == s1) { sum = sum - select; sum += copy; select = 0; } if ('5' == s1) { select = sum; } } System.out.println(sum); } } 069、【2N进制减法】 实现一个基于字符串的N机制的减法。 需要对输入的两个字符串按照给定的N进制进行减法操作，输出正负符号和表示结果的字符串。 输入描述: 输入：三个参数。 第一个参数是整数形式的进制N值，N值范围为大于等于2、小于等于35。 第二个参数为被减数字符串； 第三个参数为减数字符串。有效的字符包括09以及小写字母az，字符串有效字符个数最大为100个字 符，另外还有结尾的\\0。 限制： 输入的被减数和减数，除了单独的0以外，不能是以0开头的字符串。 如果输入有异常或计算过程中有异常，此时应当输出-1表示错误。 输出描述: 输出：2个。 其一为减法计算的结果，-1表示出错，0表示结果为整数，1表示结果为负数。 其二为表示结果的字符串。 示例1: 输入 2 11 1 输出 0 10 说明 按二进制计算 11-1 ，计算正常，0表示符号为正数，结果为10 示例2: 输入 8 07 1 输出 -1 说明 按8进制，检查到减数不符合非0前导的要求，返回结果为-1，没有其他结果内容。 package hw; import java.util.Scanner; public class Spd02 { public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()) { int a = sc.nextInt(); String s1 = sc.next(); String s2 = sc.next(); spd02(a, s1, s2); } sc.close(); } public static void spd02(int a, String s1, String s2) { if(s1.matches(\"^0.*\") || s2.matches(\"^0.*\")) { System.out.println(-1); return; } int num1 = 0,num2 = 0; try{ num1 = Integer.parseInt(s1,a); num2 = Integer.parseInt(s2,a); }catch (Exception e) { System.out.println(-1); return; } int num = num1 - num2; System.out.println(Integer.toString(num,a)); } } 070、【4VLAN资源池】 4VLAN资源池 VLAN是一种对局域网设备进行逻辑划分的技术，为了标识不同的VLAN，引入VLAN ID(1- 4094之间的整数)的概念。定义一个VLAN ID的资源池(下称VLAN资源池)，资源池中连续的VLAN用开始 VLAN-结束VLAN表示，不连续的用单个整数表示，所有的VLAN用英文逗号连接起来。现在有一个 VLAN资源池，业务需要从资源池中申请一个VLAN，需要你输出从VLAN资源池中移除申请的VLAN后的 资源池。 输入描述: 第一行为字符串格式的VLAN资源池，第二行为业务要申请的VLAN，VLAN的取值范围为[1,4094]之间 的整数。 输出描述: 从输入VLAN资源池中移除申请的VLAN后字符串格式的VLAN资源池，输出要求满足题目描述中的格 式，并且按照VLAN从小到大升序输出。 如果申请的VLAN不在原VLAN资源池内，输出原VLAN资源池升序排序后的字符串即可。 示例1： 输入 1-5 2 输出 1,3-5 说明 原VLAN资源池中有VLAN 1、2、3、4、5，从资源池中移除2后，剩下VLAN 1、3、4、5，按照 题目描述格式并升序后的结果为1,3-5。 示例2： 输入 20-21,15,18,30,5-10 15 输出 5-10,18,20-21,30 说明 原VLAN资源池中有VLAN 5、6、7、8、9、10、15、18、20、21、30，从资源池中移除15 后，资源池中剩下的VLAN为 5、6、7、8、9、10、18、20、21、30，按照题目描述格式并升序后的 结果为5-10,18,20-21,30。 示例3： 输入 5,1-3 10 输出 1-3,5 说明 原VLAN资源池中有VLAN 1、2、3，5，申请的VLAN 10不在原资源池中，将原资源池按照题目 描述格式并按升序排序后输出的结果为1-3,5。 备注: 输入VLAN资源池中VLAN的数量取值范围为[2-4094]间的整数，资源池中VLAN不重复且合法 ([1,4094]之间的整数)，输入是乱序的。 import java.util.ArrayList; import java.util.Collections; import java.util.Scanner; public class Spd04 { public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()) { String s = sc.next(); int n = sc.nextInt(); spd04(s, n); } sc.close(); } private static void spd04(String s, int n) { ArrayList list = new ArrayList<>(); String[] arr = s.split(\",\"); for (String s1 : arr) { if (s1.contains(\"-\")) { String[] s3 = s1.split(\"-\"); for (int i = Integer.parseInt(s3[0]); i 1) { sb.append(list.get(i - len) + \"-\" + list.get(i - 1) + \",\"); } else { sb.append(list.get(i - 1) + \",\"); } len = 1; } //最后一部分输出都要加一位 if (i == list.size() - 1) { if (len > 1) sb.append(list.get(i - len + 1) + \"-\" + list.get(i)); else sb.append(list.get(i)); } } System.out.println(sb.toString()); } } 071、【按身高和体重排队】 5按身高和体重排队 某学校举行运动会，学生们按编号(1、2、3…n)进行标识，现需要按照身高由低到 高排列，对身高相同的人，按体重由轻到重排列；对于身高体重都相同的人，维持原有的编号顺序关 系。请输出排列后的学生编号。 输入描述: 两个序列，每个序列由n个正整数组成（0 import java.util.ArrayList; import java.util.Collections; import java.util.HashMap; import java.util.Scanner; public class Spd05 { public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()){ int n = sc.nextInt(); int[] h = new int[n]; int[] w = new int[n]; for (int i = 0; i map = new HashMap<>(); for (int i = 0; i list = new ArrayList<>(); for (int i = 0; i result = new ArrayList<>(); for (Integer integer : list) { ArrayList temp = new ArrayList<>(); for (int i = 0; i 072、【最长子字符串的长度（一）】 给你一个字符串 s，字符串s首尾相连成一个环形 ，请你在环中找出 'o' 字符出现了偶数次最长子字符串的长度。 输入描述： 输入是一串小写字母组成的字符串 输出描述： 输出是一个整数 例： 输入： alolobo 输出： 6 public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()) { String s = sc.next(); sp34(s); } sc.close(); } private static void sp34(String s) { ArrayList list = new ArrayList<>(); for (int i = 0; i temp2 ? temp1 : temp2; System.out.println(temp); } } 073、【靠谱的车】 程序员小明打了一辆出租车去上班。出于职业敏感，他注意到这辆出租车的计费表有点问题，总是偏大。 出租车司机解释说他不喜欢数字4，所以改装了计费表，任何数字位置遇到数字4就直接跳过，其余功能都正常。 比如： 1. 23再多一块钱就变为25； 2. 39再多一块钱变为50； 3. 399再多一块钱变为500； 小明识破了司机的伎俩，准备利用自己的学识打败司机的阴谋。 给出计费表的表面读数，返回实际产生的费用。 输入描述： 只有一行，数字N，表示里程表的读数。 (1 public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()) { int num = sc.nextInt(); sp80(num); } sc.close(); } private static void sp80(int num) { //输入格式不合格的时候，考试的时候不一定要， if(String.valueOf(num).contains(\"4\")){ System.out.println(-1); return; } int trueNum= 1; int temp = trueNum; while (true) { char[] chars = String.valueOf(temp).toCharArray(); for (int i = chars.length - 1; i >= 0; i--) { if(chars[i] == '4'){ chars[i] += 1; temp = Integer.parseInt(String.valueOf(chars)); break; } } if(temp == num){ break; }else { temp++; } trueNum++; } System.out.println(trueNum); } 074、【快递运输】 075、【敏感字段加密】 076、【素数之积】 RSA加密算法在网络安全世界中无处不在，它利用了极大整数因数分解的困难度，数据越大，安全系数越高，给定一个32位正整数，请对其进行因数分解，找出是哪 两个素数的乘积。 输入描述： 一个正整数num 0 public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()) { int n = sc.nextInt(); spd76(n); } sc.close(); } private static void spd76(int n) { if(n == 2147483646){ System.out.println(-1 + \" \" + -1); return; } for (int i = 2; i i){ boolean flag = true; for (int j = 2; j 【消消乐游戏】 078、【英文输入法】 主管期望你来实现英文输入法单词联想功能。需求如下： 依据用户输入的单词前缀，从已输入的英文语句中联想出用户想输入的单词，按字典序输出联想到的单词序列，如果联想不到，请输出用户输入的单词前缀。 注意： 1. 英文单词联想时，区分大小写 2. 缩略形式如”don't”，判定为两个单词，”don”和”t” 3. 输出的单词序列，不能有重复单词，且只能是英文单词，不能有标点符号 输入描述： 输入为两行。 首行输入一段由英文单词word和标点符号组成的语句str； 接下来一行为一个英文单词前缀pre。 0 public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()) { String[] arr = sc.nextLine().split(\"[^a-zA-Z]\"); String s = sc.nextLine(); sp79(arr, s); } sc.close(); } private static void sp79(String[] arr, String s) { ArrayList list = new ArrayList<>(); for (String s1 : arr) { for (int i = 0; i 079、【整数对最小和】 给定两个整数数组array1、array2，数组元素按升序排列。假设从array1、array2中分别取出一个元素可构成一对元素，现在需要取出k对元素，并对取出的所有元 素求和，计算和的最小值 注意：两对元素如果对应于array1、array2中的两个下标均相同，则视为同一对元素。 输入描述： 输入两行数组array1、array2，每行首个数字为数组大小size(0 public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()){ int n = sc.nextInt(); int[] arr1 = new int[n]; for (int i = 0; i 080、【最远足迹】 某探险队负责对地下洞穴进行探险。探险队成员在进行探险任务时，随身携带的记录器会不定期地记录自身的坐标，但在记录的间隙中也会记录其他数据。探索工作 结束后，探险队需要获取到某成员在探险过程中相对于探险队总部的最远的足迹位置。 1. 仪器记录坐标时，坐标的数据格式为(x,y)，如(1,2)、(100,200)，其中0 public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()){ String s = sc.nextLine(); sp77(s); } sc.close(); } private static void sp77(String s) { ArrayList list = new ArrayList<>(); Pattern p = Pattern.compile(\"\\\\([1-9]\\\\d*,[1-9]\\\\d*\\\\)\"); Matcher m = p.matcher(s); while (m.find()){ list.add(m.group()); } if(list.size() == 0){ System.out.println(\"(0,0)\"); return; } int max = 0; int index = 0; for (int i = 0; i max){ max = temp; index = i; } } System.out.println(list.get(index)); } 【猜密码】 【打印任务排序】 【代码编辑器】 【德州扑克】 【斗地主之顺子】 【仿LISP运算】 【分积木】 【分月饼】 【服务器广播】 【服务失效判断】 【高效的任务规划】 【欢乐的周末】 【机器人走迷宫】 【计算堆栈中的剩余数字】 【解密犯罪时间】 【解压报文】 【九宫格按键输入】 【可以组成网络的服务器】 【篮球比赛】 【连续出牌数量】 【没有回文串】 【目录删除】 【求满足条件的最长子串的长度】 【任务最优调度】 【社交距离】 【书籍叠放】 【竖直四子棋】 【数字排列】 【贪吃蛇】 【跳格子游戏】 【图像物体的边界】 【文本统计分析】 【信道分配】 【学生方阵】 【招聘】 【找到它】 【找最小数】 【字符匹配】 【最大值】 【最长的指定瑕疵度的元音子串】 【最长方连续方波信号】 【最长广播响应】 Copyright © dsx2016.com 2023 all right reserved，powered by Gitbook该文章修订时间： 2022-10-29 19:07:51 "},"1.9_interview.html":{"url":"1.9_interview.html","title":"1.9、interview","keywords":"","body":"spd 自己面试总结 人事面试常问70题 115个Java面试题和答案 应聘时最漂亮的回答.docx JAVA面试题集合（项目11部V1.0版）.chm 应聘Java笔试时可能出现问题及其答案 Java程序员面试之葵花宝典 经典JAVA问题 Java基础方面 Java面试宝典2017 面试 一、自我介绍 面试管你好 我叫单评弟，从事软件测试有5年了，主要是java自动化和页面测试 积累扎实的Java基础，了解JSP+Servlet+JavaBean模式的WEB;了解Spring、springMVC,mybits等开源框架 项目中主要负责版本需要跟踪和小组专项任务工作分配等、保证版本有质量的发布 平时组织专项梳理和内部培训 谢谢 二、你的个性 比较随和、适应能力、乐于助人、适应能力和幽默感 三、你对加班的看法？ 如果是工作需要我会义不容辞加班。 没有任何家庭负担，可以全身心的投入工作。但同时，我也会 提高工作效率，减少不必要的加班 四、你对薪资的要求？ 我对工资没有硬性要求。我相信贵公司在处理 我的问题上会友善合理。我注重的是找对工作机会，所以只要 条件公平，我则不会计较太多 五、为什么要离职? 1、项目被砍 2、前公司搬迁， 3、自身职业发展和规划需要 六、什么时候可以到岗 1、如果我可以通过的话我可以和公司做好交接，最迟一个月 2、如果贵公司确认录用我的话我在一周内到岗 七、你还有什么想了解的吗 1、贵公司对新入公司的员工有没有什么培训项目，我可以参加吗？ 2、贵公司的晋升机制是什么样的？ ---------------------------------------------------------------- 一、测试方法 1、等价类 2、场景法 3、流程法 4、边界值 5、因果图 6、正交排列组合 7、补充和错误推导 二、性能指标 1、硬件要求 2、软件要求 3、测试组网 4、性能指标 1、系统性能指标 1、系统处理能力 2、吞吐量 3、并发用户数 4、错误率 2、资源性能指标 1、CPU 2、内存 3、磁盘吞吐量 4、网络吞吐量 PS: 1、覆盖所有改造参数(正向) 2、组合可行参数(正向_覆盖率的问题，考虑人力和时间成功) 3、参数边界(逆向_比如年龄边界) 4、如果参数的取值范围是枚举，需要覆盖所有的枚举值(测试所有的数据) 5、空数据(逆向_不录入数据) 6、包含特殊字符(逆向_+-*/%@*_) 7、越界数据(逆向_比如长度太长或太短) 8、错误数据(逆向_比如错误的手机号，身份证，重复的ID) ------------------------------------------------------------------------------ 1封装： 封装是保证软件部件具有优良的模块性的基础，封装的目标就是要实现软件部件的“高内聚、低耦合”，防止程序相互依赖性而带来的变动影响。 继承： 在定义和实现一个类的时候，可以在一个已经存在的类的基础之上来进行，把这个已经存在的类所定义的内容作为自己的内容，并可以加入若干新的内容， 或修改原来的方法使之更适合特殊的需要，这就是继承。继承是子类自动共享父类数据和方法的机制，这是类之间的一种关系，提高了软件的可重用性和可扩展性。 多态： 多态是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象， 该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。 Overload是重载的意思，Override是覆盖的意思，也就是重写。 重载Overload表示同一个类中可以有多个名称相同的方法，但这些方法的参数列表各不相同（即参数个数或类型不同）。 重写Override表示子类中的方法可以与父类中的某个方法的名称和参数完全相同，通过子类创建的实例对象调用这个方法时， 将调用子类中的定义方法，这相当于把父类中定义的那个完全相同的方法给覆盖了，这也是面向对象编程的多态性的一种表现。 MVC 1.DispatcherServlet：前端控制器，接收请求，调用其他组件处理请求响应请求，相当于转发器，中央控制器，是整个控制流程的中心。 2.HandlerMapping: 处理器映射,主要功能是实现请求派发，找到请求和控制器之间的对应关系。 3.Controller:控制器，接收处理前端控制器分发的请求，将执行的结果(ModelAndView)返回给前端控制器。 4.ModelAndView:封装数据模型和视图信息。 5.ViewResolver:视图解析器，根据视图名称解析后返回一个真正的页面。 Copyright © dsx2016.com 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-04-02 22:52:09 "},"2.1_shares.html":{"url":"2.1_shares.html","title":"2、股票","keywords":"","body":"投资方向(二八原则) 1、学会空仓 2、宁可错过，不可重仓 3、做正解的事 顺势轻仓，截断亏损，让利润奔跑！ 目标：不亏损，不大亏，赚经验 1、进货 2、洗盘 3、试盘 4、拉升 5、出货 高涨时候卖出，低估的时候买入。 指数大涨，题材出货。 注意压力位和支撑位。 题材地位买入， 1、20%的资金投资平时自己关注的股票(量比4倍以上，量能迅速放大，非st，阳线，深股主板非新股，股价小于20，流通值小于40亿),买入点：当价格大于当前试盘线的买入或者成功量等于试盘线前的成交量。 2、80%的资金投资当前最热门的题材(龙头方向)---每个时期的热点不同紧跟踪题材热点。 3、有一块只赚七毛，注意风险(会买的是徒弟，会卖的是师傅)， *、当股价下降到最大盈利时期的80%时卖出 *、止损卖出、当股价底于买入那天的最低卖出或者macd出现死叉 *、 盈利卖出、量价出现背离或者macd出现死叉 一、股票投资 一、股市投资的误区 1、追求一夜暴富 2、分不清运气和能力 3、患得患失 4、这次不一样 5、羊群效应 6、过于重视股份 7、投资加杠杆 8、爱上自己的股票 1、基本面 1、利率： 利率上升->银行->股票下跌 2、通货膨胀 通货膨胀->股票上涨 1、ROE(净资产收益率=净利润/净资产) 净利润=公司税后利润 净资产=总资产-总负债 2、PE 2、K线 1、三个红兵(三边阳) *.红三兵是最常见的K线组合，该组合出现时，后势看涨的情况居多。 *.线三兵出现后，次日开始分批介入比较稳妥。 *.如果红三兵突破近期反反弹高点，并且伴随着成交量的逐渐放大，可引起密切关注。 2、三只乌鸦(三连阴) *.三连阴不可怕，关键看后续交易日能否修复形态，若形态很快修复说明多方转强，若形态不修复说明空方依旧强势，应坚决退出观望。 *.形态修复以恢复到第一根阴线开盘价位置为标志。 3、一阳吞三(两)阴 *.一阳吞三阴是典型的反击或攻击组合，表明在调整过程中多方力量突然爆发。 *.操作上可短线积极跟进。 5、断头铡刀 *.断头铡刀就是一根长阴线连续击破几根阳线(均线)。 *.该图形是市场陷入恐慌性出出逃的标志，当有大的利空出现时往往会有这种图形出现 *.俗话说，断头铡刀，逃之夭夭。 4、两阳夹一阴 *.最常见的K线组合，表明短期调整结束。 *.上涨趋势中股份有望新的突破，短线可跟进，而下跌趋势中应继续观望。 6、早晨之星 *.早晨之星的K线形式一般出现在下降趋势的末端，是见底信号，后市看涨。 7、黄昏之星 *.若股价出现连续快速上涨，并有巨额成交出现时，星线出现后有长阴线，则是见顶信号，应减仓退出操作。 8、多个阳线连续出现 *.多个连阳出现意味着股价持续上涨，如果10日均线不能被跌破，坚决持有。 9、缺口 *.缺口是批股价变动中有一段价格没有任何交易，显示在股价K线图上是一个空白区域，这个区域称之“缺口”，通常又称为跳空 *.在K线图中缺口反映出某天股价最高价比后一交易日最低价还低或者最低价比后一日最高价还高 10、缺口回补 *.当股价出现缺口，经过几天，甚至更长时间的变动，然后反转过来，回到原来缺口的价位时，称为缺口的封闭，又称回补或补空。 11、突破缺口 *.突破缺口是整理形态完成后突破盘局时产生的缺口 *.突破缺口的分析意义最大，当股价以一个很大的缺口跳空远离形态时，这表示真正的突破已经形成，突破缺口越大表示未来的变动越强烈。如果股价突破支撑线或压力（阻力）线后以一个很大的缺口跳离形态，表明突破十分有力。 *.突破缺口的出现有两种情况，一是向上的突破缺口，二是向下的突破缺口， *.如果出现向上突破缺口要积极跟进，出现向下的突破缺口则就减仓退出。 12、持续性缺口 *.在上升或下跌途中出现缺口，多是持续性缺口。 *.持续缺口是股价大幅变动中途产生的，因而不会于短时期内封闭。 13、消耗性缺口 *.消耗性缺口股价在大幅度波动过程中作最后一次跳跃，通常消耗性缺口大多在恐慌性抛售或消耗性上升的末端出现，所以也叫竭尽缺口。 *.消耗性缺口和普通缺口一样在短期内会回补缺口。 *.消耗性缺口在上升的末端多有最大成交出现。 14、除权缺口 *.由于制度因素的原因，股价在上市公司送配后，股价会出现除权，除息缺口，表现在除权价与股权登记日的收盘之间跳空。 *.除权缺口被回补则是垃填权行情。 15、普通缺口 *.普通缺口并无特别的分析意义，一般在几个交易日内便会完全填补。 3、指标 一、MA：移动平均线的格兰维尔八大法则 一、买入四法则 1、MA从下降逐渐走平，而价格从MA的下方突破MA时，是买进信号。 2、价格走在MA之上并且下跌，但未跌破MA，价格又上升时可以加码买进。 3、价格虽然跌到MA下方，但MA在上场，不久价格又回到MA上的时候为买进信号。 4、价格低于MA并突然暴跌，远离MA之时，极可能再度趋向MA，是买进时机。 二、卖出四法则 5、价格在上升过程中并走在MA之上，突然暴涨并远离MA，很可能再度趋向MA,是卖出时机。 6、MA从上升逐渐走平，而价格从MA的上方往下跌破MA时，是卖出信号。 7、价格在MA之下并上涨，但未突破MA又告回落，是卖出时机。 8、价格向止突破MA，但又立刻回到MA之下，而且MA仍在继续下跌时，是卖出时机。 PS:威尔认为第三条和第八条为初学者慎用，同时认为若将第一条和第二条，第六条和第七条合并使用可以捕捉到最佳买进和卖出时机，第四条和第五条可结合乘离率指标使用以提高其适用性和可操作性。 三、金三角和黑三角 1、金三角：短期均线(20)由下往上穿过中期均线(50)和长期均线(100)，中期均线由下往上穿过长期均线从而形成一个封闭的三角形。金三角一般与多头排列同步形成，代表多方聚积的上攻能量，是一种典型的买进信号 2、黑三角：短期均线由上下穿过中期均线和长期均线，中期均线由上下穿过长期均线从而形成一个封闭的三角形。黑三角一般与空头排列同步形成，代表空方聚积了一定的杀跌能量，是一种典型的卖出信号。 四、六线之上与六线之上(5,10,15,20,25,30) 1、六线之上：价位通过长期时间的下跌或短暂的回调之后，第一次支行在6条移动平均线以上。6线之上是一种典型的做多信号，是价格上涨的必经之途，其信号时间要远远的早于守多排列，须与其他技术分析方法配合其概率更高。 2、六线之下：和六线之上相反。、 二、MACD： *.趋势在一段时间内是可以把握的;每个指标都有无效的时候，没有指标会始终有效，我闪的工作就是搞清楚指标何时有效，对我们做股票有帮助 每一句：DIFF也叫当时离差=短期(12天)均线的平滑均价-长期(26天)均线的平滑均价；当均线上以多头形式排列时，DIFF值会出现上涨，否则交出现下跌。 第二句：DEA也叫平均离差=（9天）当日离差的平滑均价 第三句：MACD=红绿柱=DIFF-DEA放大三倍。 PS:当DIF，DEA指标处于0轴以下的时，短期内(8-13个交易日)连续两次发生金叉的时候要发生爆涨 应用 一、顺势操作---金叉/死叉战法：股份创新高，MACD指标没有创新高 *.就是追涨杀跌，在多头市场时金叉买入，在空头市场时死叉卖出。 二、逆市操作---顶底背离战法：股份创新底，MACD指标没有创新底 *.就是逃顶抄底，在顶背离时卖空，在底背离时买多。 三、波浪战法 *.只买零轴上方第一个金叉 *.如果是驱动浪就是买在第三浪起沸点 *.如果是调整浪就买在C浪起涨点 第1浪： *.几乎半数以上的第一浪，是属于营造底部形态的第一部分，第1浪是循环开始，由于这估行情的上升出现在空头市场跌市后的反弹和反转，买方力量并不强大，加上空头继续存在卖压，第1浪的涨幅通常是5浪中最短的行情 第2浪： *.2浪的终点通常高于1浪的起点，这一浪是下跌浪，由于市场人士误以为熊市尚未结束，其调整下跌的幅度相当大几乎吃掉第1浪的大部分升幅，末期市场出现惜售心理，抛售压力逐渐衰竭，第2浪调整才会宣告结束，在此良中经常出现转向形态，如头肩底，双底等，但2浪的终点必须高于1浪的起点 第3浪： *.第3浪的涨势往往是最大，最有爆发力的上升浪，这段行情持续的时间与幅度，经常是最长的，市场投资者信心恢复，成交量大幅上升，常出现突破信号，例如裂口跳长等，这段行情走势非常猛烈，由于第3浪涨势激烈，经常出现“延长波浪”的现象，3浪的终点必须高于1浪的终点 第5浪： *.在股市中第5浪的涨势通常小于第3浪，速度和角度都有明显的下降，通常容易出现价格和指标之间形成顶背离结构。5浪的获利难度 对比3浪有明显的增加，5浪终点必须高于3浪的终点。 A浪： *.A浪下跌，速度和要明显已于上升途中的调整(如2浪和4浪)，力度更强，持续的时间也比较长 B浪： *.B浪支行的时间通常要比A浪短，速度也要略慢一些，一般A浪下跌没有来的及卖，B浪反弹可以成为次高点，也是一个相对较好的卖点，B浪的终点必须低于A浪的起点 四、背离 一、顶背离 *.股份创新高但是MACD没有创新高-卖出 二、底背离 *.股价创新底但是MACD没有创新底-买入 三、KDJ： 四、成交量： 97、参数设置 一、技术面参数 macd设置为 (10、20、7) 98、买入规则(下跌行情不做) 一、技术面选股 1、水下两次金叉(但是第二次金叉距离上一次的死叉不小于等于5且最低点大于第一次的最低点)或水上一次金叉(也可以水上两次金叉第二次次金叉的的距离小于等于3)， 2、成交量大于3倍， 3、(可选)分时图中大于等于两次脉冲上涨，且当的白线在黄线上(当前价格大于均价)、且尾盘不大于三个点， 二、选股查找(同花顺) macd金叉；沪深a股主板非新股；量比三倍以上；量能迅速放大；非st 99、卖出规 一、技术面卖出 1、止损卖出、当股价底于买入那天的最低卖出或者macd出现死叉 2、 盈利卖出、量价出现背离或者macd出现死叉 Copyright © dsx2016.com 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-06-17 23:16:34 "},"2.2_formula.html":{"url":"2.2_formula.html","title":"2.2、公式","keywords":"","body":"一、指标编写 { 板块-多投 有游资参与 } BK1 := (STR2CON(CODE)>880300 AND STR2CON(CODE)880500 AND STR2CON(CODE)=880899 AND STR2CON(CODE)MA(C,13) AND MA(C,13)>MA(C,21) AND MA(C,21)>MA(C,34); XG := BK AND DT AND COUNT(DYNAINFO(23)>=10, 5); ZZ :=REF(XG,RF); OK :DRAWICON(ZZ,REF(C,RF),1); { 板块-回踩 有游资参与 } BK1 := (STR2CON(CODE)>880300 AND STR2CON(CODE)880500 AND STR2CON(CODE)=880899 AND STR2CON(CODE)MA(C,13) AND MA(C,13)>MA(C,21) AND MA(C,21)>MA(C,34); XG := BK AND DT AND COUNT(DYNAINFO(23)>=10, 5) AND L880300 AND STR2CON(CODE)880500 AND STR2CON(CODE)=880899 AND STR2CON(CODE)MA(C,13) AND MA(C,13)>MA(C,21) AND MA(C,21)>MA(C,34); XG := BK AND DT; ZZ :=REF(XG,RF); OK :DRAWICON(ZZ,REF(C,RF),1); { 板块-回踩 无游资参与 } BK1 := (STR2CON(CODE)>880300 AND STR2CON(CODE)880500 AND STR2CON(CODE)=880899 AND STR2CON(CODE)MA(C,13) AND MA(C,13)>MA(C,21) AND MA(C,21)>MA(C,34); XG := BK AND DT AND L1.097; BB:=BARSLAST(AA AND V/REF(MA(V,5),1)>4 AND COUNT(AA,40)REF(DIF,DD) AND C5 } DIF:= 10*\"MACD.DIF\"(10,20,7) ; DEA:= 10*\"MACD.DEA\"(10,20,7) ; MYMACD:= 10*\"MACD.MACD\"(10,20,7) ; CF:=IF(CODELIKE('300'),0,1) AND IF(CODELIKE('301'),0,1) AND IF(CODELIKE('688'),0,1); AA:=H/REF(C,1)>1.097; BB:=BARSLAST(AA AND V/REF(MA(V,5),1)>5 AND COUNT(AA,40)CC AND CC0 AND C1.097; BB:=BARSLAST(AA AND COUNT(AA,40)CC AND CC=0 AND CREF(DIF,CC) AND CREF(DIF,BB) AND CMAX(REF(MIN(O,C),2),REF(MAX(O,C),1)); EE:=REF(CF AND DD,RF); OK:DRAWICON(EE,REF(C,RF),1); { 背离_03 } CF:=IF(CODELIKE('300'),0,1) AND IF(CODELIKE('301'),0,1) AND IF(CODELIKE('688'),0,1); DIF:=\"MACD.DIF\"(10,20,7); DEA:=\"MACD.DEA\"(10,20,7); AA:=BARSLAST(CROSS(DIF,DEA)); BB:=REF(AA,1)+1; CC:=BARSLAST(CROSS(DIF,DEA) AND DIF>REF(DIF,BB) AND CREF(HHV(C,BB),CC) AND MA(C,60)>REF(MA(C,60),1) AND C>MA(C,60) AND C>=REF(C,CC) AND REF(C,1)1.097; BB:=BARSLAST(AA AND COUNT(AA,10)>1); CC:=BARSLAST(CROSS(MA(C,5),MA(C,10))); DD:=BARSLAST(CROSS(MA(C,5),MA(C,20))); EE:=BARSLAST(CROSS(MA(C,10),MA(C,20))); MP:=REF(MAX(O,C),BB); FF:=BBCC AND CC>=DD AND DD>=EE AND EEO AND MP>C,BB) AND REF(O,1)MAX(REF(MIN(O,C),2),REF(MAX(O,C),1)); GG:=REF(CF AND FF,RF); OK:DRAWICON(GG,REF(C,RF),1); { 龙回头_02 通润装备 收阴线或者长上引线就卖 } MACD:=10*\"MACD.MACD\"(10,20,7); CF:=IF(CODELIKE('300'),0,1) AND IF(CODELIKE('301'),0,1) AND IF(CODELIKE('688'),0,1); AA:=H/REF(C,1)>1.097; BB:=BARSLAST(AA AND COUNT(AA,10)>1); CC:=BARSLAST(CROSS(MA(C,5),MA(C,10))); DD:=BARSLAST(CROSS(MA(C,5),MA(C,20))); EE:=BARSLAST(CROSS(MA(C,10),MA(C,20))); MP:=REF(MAX(O,C),BB); FF:=BBCC AND CC>=DD AND DD>=EE AND EEO AND MP>C,BB) AND MA(C,10)>=MA(C,20) AND L=MA(C,20) AND MACD>=0; GG:=REF(CF AND FF,RF); OK:DRAWICON(GG,REF(C,RF),1); { 告警_01 天鹅股份 V>5 } CF:=IF(CODELIKE('300'),0,1) AND IF(CODELIKE('301'),0,1) AND IF(CODELIKE('688'),0,1); AA:=REF(C,1)/REF(C,2)>1.097; BB:=BARSLAST(AA AND COUNT(AA,40)O AND MP>C,BB) AND C>BP; DD:=REF(CF AND CC,RF); OK:DRAWICON(DD,REF(C,RF),1); { 告警_02 天鹅股份 } CF:=IF(CODELIKE('300'),0,1) AND IF(CODELIKE('301'),0,1) AND IF(CODELIKE('688'),0,1); AA:=REF(C,1)/REF(C,2)>1.097; BB:=BARSLAST(AA AND COUNT(AA,40)O AND MP>C,BB) AND C>BP; DD:=REF(CF AND CC,RF); OK:DRAWICON(DD,REF(C,RF),1); { 最新 中通客车 竞业达 } CF:=IF(CODELIKE('300'),0,1) AND IF(CODELIKE('301'),0,1) AND IF(CODELIKE('688'),0,1); DIF:=\"MACD.DIF\"(10,20,7) ; DEA:=\"MACD.DEA\"(10,20,7) ; AA:=H/REF(C,1)>1.097 AND C>O; BB:BARSLAST(AA AND V/REF(MA(V,5),1)>5 AND COUNT(AA,40)CC AND CC二、连续四连阳:RF AA:=REF(C,3)>REF(O,3); BB:=REF(C,2)>REF(C,3) AND REF(V,2)REF(O,2); CC:=REF(C,1)>REF(C,3) AND REF(V,1)REF(O,1); DD:=REF(C,0)>REF(C,3) AND REF(V,0)REF(O,0); EE:=REF(AA AND BB AND CC AND DD,RF); OK:DRAWICON(EE,C,1); 三、水上金叉：CT,RF MACD01:=10*\"MACD.MACD #DAY\"(10,20,7); DIF01:=\"MACD.DIF #DAY\"(10,20,7); DEA01:=\"MACD.DEA #DAY\"(10,20,7); DIF02:=REF(DIF01,RF) ; DEA02:=REF(DEA01,RF) ; DIF03:=REF(DIF01,RF+RF); DEA03:=REF(DEA01,RF+RF); BB:=CROSS(DIF02,DEA02); CC:=CROSS(DEA03,DIF03); DD:=BB AND CC AND DEA02>0 AND DIF01>DEA01 AND DEA01>0; DRAWICON(DD,H,1); 四、最近使用的 { 首板 } AA:=C/REF(C,1)>1.097 AND REF(C,1)/REF(C,2)REF(DIF,CC) AND C5000000000 AND FINANCE(30)/CAPITAL/FINANCE(34)>3 AND DEA>0; EE:=REF(AA AND DD,RF); OK:DRAWICON(EE,REF(C,1),1); { 抄底_01 一个月内满足的 中通客车 竞业达 大于前30天的最高值 } CF:=IF(CODELIKE('300'),0,1) AND IF(CODELIKE('301'),0,1) AND IF(CODELIKE('688'),0,1); DIF:=\"MACD.DIF\"(10,20,7) ; DEA:=\"MACD.DEA\"(10,20,7) ; AA:=H/REF(C,1)>1.097 AND C>O AND C>REF(HHV(H,30),1); BB:=BARSLAST(AA AND V/REF(MA(V,5),1)>4 AND COUNT(AA,30)1.097; BB:=BARSLAST(AA AND COUNT(AA,40)REF(MA(V,5),1) AND C>O); MP:=REF(C,BB); BP:=REF(O,BB); CC:=BBO AND MP>C,BB) AND CROSS(DIF,DEA) AND C1.097; BB:=BARSLAST(AA AND COUNT(AA,5)>1); CC:=REF(BB,1)+1; DD:=REF(BARSSINCEN(AA,20),CC); CP:=REF(MIN(O,C),CC+DD); EE:=CCLLV(L,CC) AND CROSS(DIF,DEA); FF:=REF(CF AND EE,RF); OK:DRAWICON(FF,REF(C,1),1); { 龙回头_02 通润装备 收阴线或者长上引线就卖 } MACD:=10*\"MACD.MACD\"(10,20,7); CF:=IF(CODELIKE('300'),0,1) AND IF(CODELIKE('301'),0,1) AND IF(CODELIKE('688'),0,1); AA:=H/REF(C,1)>1.097; BB:=BARSLAST(AA AND COUNT(AA,10)>1); CC:=BARSLAST(CROSS(MA(C,5),MA(C,10))); DD:=BARSLAST(CROSS(MA(C,5),MA(C,20))); EE:=BARSLAST(CROSS(MA(C,10),MA(C,20))); MP:=REF(MAX(O,C),BB); FF:=BBCC AND CC>=DD AND DD>=EE AND EEO AND MP>C,BB); GG:=REF(CF AND FF,RF); OK:DRAWICON(GG,REF(C,RF),1); { 龙回头_03 三红兵 通润装备 收阴线或者长上引线就卖 查找一个月内的 } CF:=IF(CODELIKE('300'),0,1) AND IF(CODELIKE('301'),0,1) AND IF(CODELIKE('688'),0,1); DIF:= 10*\"MACD.DIF\"(10,20,7) ; DEA:= 10*\"MACD.DEA\"(10,20,7) ; AA:=H/REF(C,1)>1.097; BB:=BARSLAST(AA AND COUNT(AA,5)>1); CC:=REF(BB,1)+1; DD:=REF(BARSSINCEN(AA,20),CC); CP:=REF(MIN(O,C),CC+DD); DE:=REF(C,3)REF(O,2) AND REF(C,1)>REF(O,1) AND C>O; EE:=CCLLV(L,CC) AND DE AND COUNT(DE,BB)=1; FF:=REF(CF AND EE,RF); OK:DRAWICON(FF,REF(C,1),1); { 龙回头_04 金叉 华脉科技 封板当天的>5分钟，成交量就是最高 } CF:=IF(CODELIKE('300'),0,1) AND IF(CODELIKE('301'),0,1) AND IF(CODELIKE('688'),0,1); DIF:= 10*\"MACD.DIF\"(10,20,7) ; DEA:= 10*\"MACD.DEA\"(10,20,7) ; AA:=H/REF(C,1)>1.097; BB:=BARSLAST(AA AND COUNT(AA,5)>2); HV:=REF(V,BB); HP:=REF(H,BB); CC:=BBC,BB) AND EVERY(HV>V,BB) AND CROSS(DIF,DEA); DD:=REF(CF AND CC,RF); OK:DRAWICON(DD,REF(C,RF),1); { 龙回头_最强 华脉科技 收阴线或者长上引线就卖 查找一个月内的 } CF:=IF(CODELIKE('300'),0,1) AND IF(CODELIKE('301'),0,1) AND IF(CODELIKE('688'),0,1); DIF:= 10*\"MACD.DIF\"(10,20,7) ; DEA:= 10*\"MACD.DEA\"(10,20,7) ; AA:=C/REF(C,1)>1.096 AND O=C; BB:=BARSLAST(AA AND COUNT(AA,5)>1); CC:=REF(BB,1)+1; HV:=REF(V,BB); HP:=REF(H,BB); DD:=CCV AND HP>O AND HP>C,CC) AND CROSS(DIF,DEA); EE:=REF(CF AND DD,RF); OK:DRAWICON(EE,REF(C,RF),1); Copyright © dsx2016.com 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-07-16 19:21:53 "},"3.1_medicine.html":{"url":"3.1_medicine.html","title":"3、医药","keywords":"","body":"中药学 一、书 1、实用中医学 2、千家妙方 3、实用内科诊断治疗学 二、药 一、解表药 一、发散风寒药 1、荆芥： 2、紫苏： 二、发散风热药 三、发散风湿药 二、祛暑药 三、泻下药 四、驱虫药 五、祛寒药 六、清热药 七、止咳化痰平喘药 八、理气药 九、消导药 十、理血药 十一、渗湿利水药 十二、安神镇惊药 十三、固涩药 十四、补养药 三、方 利水： ​ 补养： 金樱子15，车前子15，白茅根20，旱莲草20，枸杞子，芡实20，何首乌15，当归15，赤芍15，熟地20，陈皮15，半夏15，党参20，白术20，茯苓15，甘草10 生发 当归30，杭白芍15，鱼鳔胶(烊化)10，菟丝子10，补骨脂9，枸杞子10，龙齿10，怀牛膝10，代赭石6，淡竹叶10，连翘心5，炙甘草6，首乌藤20， Copyright © dsx2016.com 2023 all right reserved，powered by Gitbook该文章修订时间： 2022-10-29 19:07:51 "},"4.1_passwd.html":{"url":"4.1_passwd.html","title":"4、备忘","keywords":"","body":"一、QQ 493427970:Ping100544.*** 320964266: 996582005:ShanDisk.1314*** 1103582828: 1203435268: 485241804：Ping889966.*** 二、WX 996582005:ShanDisk.1314*** 320964266:ShanDisk.1314*** 1103582828:ShanDisk.1314*** 1203435268:ShanDisk.1314*** 三、YP&ZFB 996582005qq.com: 320964266qq.com: 1103582828qq.com: 1203435268qq.com: shanpd@sina.com P***1**3**.**m 四、git https://gitee.com/ https://github.com/ shanpd@sina.com s***p*.***4**3 五、ZQ 华泰：666638047710/1 六、个人所得税 证件号 s***p*.***4**3 Copyright © dsx2016.com 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-04-05 22:42:06 "}}